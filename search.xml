<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[react-router温故知新]]></title>
    <url>%2F2018%2F01%2F23%2Freact-router%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%2F</url>
    <content type="text"><![CDATA[谁等待了足够的时间，谁就将永远等待下去，超过了某一个期限，就什么也不会发生了。 —— 塞缪尔·贝克特 《马龙之死》 嵌套注释：导航栏 应该在每一个屏幕中都有，如果没有react router，我们将把ul封装为一个组件，比如Nav，然后将 Nav 渲染近每一个屏幕； 但是随着项目的复杂度的增加，会使得项目代码冗余，react-router提供了另外一种方式和嵌套路由共享UI React Router embraces this by letting you nest your routes, which automatically becomes nested UI. 通过让你嵌套路由，自然形成嵌套的UI The best way to build large things is to stitch small things together. 这是react-router的真正威力，每一条route都可以作为一个独立的应用程序来开发这才是react-route的真正威力 Active LinksLink 不同于 a 标签的一个原因是，Link 可以区别这个链接是否是被激活的(active)，以便于开发者标记不同的样式行内样式 或者 className都是支持的 1234567// modules/App.js&lt;li&gt;&lt;Link to=&quot;/about&quot; activeStyle=&#123;&#123; color: &apos;red&apos; &#125;&#125;&gt;About&lt;/Link&gt;&lt;/li&gt;&lt;li&gt;&lt;Link to=&quot;/repos&quot; activeStyle=&#123;&#123; color: &apos;red&apos; &#125;&#125;&gt;Repos&lt;/Link&gt;&lt;/li&gt;// modules/App.js&lt;li&gt;&lt;Link to=&quot;/about&quot; activeClassName=&quot;active&quot;&gt;About&lt;/Link&gt;&lt;/li&gt;&lt;li&gt;&lt;Link to=&quot;/repos&quot; activeClassName=&quot;active&quot;&gt;Repos&lt;/Link&gt;&lt;/li&gt; 如果将每一个有激活样式的Link都写上样式，会产生很多冗余代码，所以我们可以把有激活样式的Link封装一下,在需要使用的时候 引用 封装后的NavLink1234567891011121314// moudle/NavLink.jsimport React from &apos;react&apos;;import &#123;Link&#125; from &apos;react-router&apos;;export default class NavLink extends React.Component&#123; render()&#123; return &lt;Link &#123;...this.props&#125; activeStyle = &#123;&#123;color:&apos;red&apos;&#125;&#125;&gt;&lt;/Link&gt; &#125;&#125;// moudle/App.js&lt;li&gt;&lt;NavLink to=&quot;/about&quot; &gt;About&lt;/NavLink&gt;&lt;/li&gt;&lt;li&gt;&lt;NavLink to=&quot;/repos&quot; &gt;Repos&lt;/NavLink&gt;&lt;/li&gt; URL Params1/repos/reactjs/react-rpute 1/repos/:userName/:repoName URL中用 ： 开头的参数的值，可以在组件中用 this.props.params[name]取到]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>react-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器的工作原理]]></title>
    <url>%2F2018%2F01%2F16%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[人的尊严就在于，能够对我们看似前后矛盾的命运逻辑，反复的质疑。—— 英格玛·伯格曼《第七封印》 浏览器的主要功能 浏览器的主要功能是将用户选择的web资源呈现出来，需要从数据库请求资源，并将其显示在浏览器窗口中，资源的格式通常是html，也包括PDF、image以及其他格式。用户用URL（Uniform Resource Identifier统一资源标识符）来指定请求资源的位置 HTML和CSS规范中规定了浏览器解释html文档的方式，由 W3C组织对这些规范进行维护，W3C是负责制定web标准的组织。 虽然各大浏览器厂商纷纷开发自己的扩展，遵循的规则并不完善，为web开发者带来严重的兼容性问题，但是浏览器的用户界面差不多，常见的用户界面 用来输入URL的地址栏 前进、后退按钮 书签选项 用于刷新、暂停当前加载文档的刷新、暂停按钮 用于到达主页的主页按钮 浏览器的主要构成 用户界面——包括 地址栏、前进后退按钮、书签目录、（所看到的除了用来显示你所请求的页面的主窗口之外的部分） 浏览器引擎——用来查询以操作渲染引擎的接口 渲染引擎——显示请求的内容，例如如果请求的html，他负责解析html及css，并将解析后的结果显示出来 网络——用来完成网络调用，例如http请求，它是平台无关的接口 UI后端——用来绘制类似组合选择框和对话框等基本组件，具有不特定于某个平台的通用接口 JS解释器 数据存储]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[箭头函数]]></title>
    <url>%2F2018%2F01%2F02%2F%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[箭头函数表达式的语法比函数表达式更短，并且不绑定自己的this，arguments，super或 new.target。这些函数表达式最适合用于非方法函数，并且它们不能用作构造函数。 基础语法123456(param1,param2,...,paramN)=&gt;&#123;retrun expression&#125;//只有一个参数时，括号可以选择不加（singleParam）=&gt;&#123;statements&#125; singleParam=&gt;&#123;statements&#125;//当没有参数时，括号是必须的（）=&gt;&#123;statements&#125; 高级语法12345678910//加括号的函数体返回对象字面表达式：param =&gt; (&#123;foo: bar&#125;)//支持剩余参数和默认参数(参数1, 参数2, ...rest) =&gt; &#123;函数声明&#125;(参数1 = 默认值1,参数2, …, 参数N = 默认值N) =&gt; &#123;函数声明&#125;//同样支持参数列表解构let f = ([a, b] = [1, 2], &#123;x: c&#125; = &#123;x: a + b&#125;) =&gt; a + b + c;f(); // 6 描述引入箭头函数的作用：更简短的函数并且不绑定this 更短的函数12345678910111213var materials = [ &apos;Hydrogen&apos;, &apos;Helium&apos;, &apos;Lithium&apos; ]; materials.map(function(materials)&#123; return materials.lemght &#125;); //[8,6,7] materials.map(maters=&gt;&#123; return materials.length &#125;); //[8,6,7] materials.map(masters=&gt;materials.length); // [8,6,7] 注：{}里表达式，需要 return,才会有返回值 不绑定this在箭头函数出现之前，每一个新创建的函数都有自己的this（在构造函数中是一个新对象，在严格模式的函数调用中是undefined，如果该函数被称为‘对象方法’则是基础对象）12]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git用法小结]]></title>
    <url>%2F2018%2F01%2F01%2Fgit%E7%94%A8%E6%B3%95%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在一个日益麻木不仁的世界上，我们的知觉都已生了硬痂。—— 罗伯特·詹姆斯·沃勒 《廊桥遗梦》 第4章 通过实际操作学习git4.1 git基本操作 git init— 初始化仓库生成 .git 文件夹，这个 .git 目录里管理着当前目录内容所需的仓库数据，在Git中，我们将这个目录的内容成为“附属于该仓库的工作树”。 git status— 查看仓库的状态 mkdir abc 创建文件夹abc touch abc.html 创建文件 abc.html git log — 查看提交日志(1) 只显示指定目录、文件的日志 $ git log README.md(2)显示文件的具体改动内容 $ git log -p git diff查看工作树和暂存区的区别不妨养成在$ git commit之前，$ git diff HEAD,查看本次提交和上次提交有什么区别HEAD是指针，指向当前分支的最新一次提交 4.2分支的操作 git branch— 显示分支一览表 $ git checkout -b 创建、切换分支如果你想以当前的master分支为基础创建新的分支，我们需要用到$git checkout -b(1)创建 feature-A 分支，并进行提交1$ git checkout -b feature-A //创建分支 feature-A 等同于12$ git branch feature-A //创建分支$ git checkout feature-A //切换到分支 (2)切换到 master 分支1$git checkout master //checkout 查看 git checkout - ‘-‘ 连字符表示切换回上一个分支 git merge — 合并分支假设feature-A 这个特性分支开发完毕，想要将他合并到主干分支master中。(1)首先切换到 master 分支1$git checkout master (2)然后合并分支， 为了历史记录，需要创建合并提交，因此在合并时加上 --no-ff参数1$ git merge --no-ff feature-A 咳咳咳！！！！敲黑板，这个时候会进入 vim 编辑器状态，想当时我折腾了半天不知道那是个啥随后编辑器会启动，用于录入和并提交的信息，默认信息中已经包含了是从分支合并过来的相关内容，所以保存就好了，然后关闭编辑器先退出输出状态 Esc，然后进入输入状态 shift + ：，最后输入 wq！（保存并退出）vim命令总结(3)成功的话，就会看到 4.. git log --graph — 以图标的形式查看分支此时此刻很有成就感，成功新建了一个分支，并且合并啦 4.3 更改提交的操作 git reset — 回溯历史版本如果此时我想创建一个feature-A 的兄弟分支，feature-B，怎么办呢？那就需要回溯到创建A的分支之前的节点，创建一个B分支，（1）要让仓库的HEAD、暂存区、当前工作树回溯到制定状态，需要用到git reset --hard命令，只需要提供目标时间点的哈希值，就可以完全恢复至改时间点的状态。 （2）此时已经恢复到了创建分支A之前的节点，创建分支B1$ git checkout -b feature-B 随便写点什么，并且提交，一定要提交哦，也就是git add 、git commit，不然没有记录，如果自己不小心把代码搞丢了，是找不到的 （3）分支培育好了，要合并了 ———推进至A分支合并后的状态git log 命令只能查看以当前状态为终点的历史日志，所以这里要使用 git reflog命令，查看当前仓库的操作日志 ，寻找此时的哈希值，然后git reset --hard,之后合并2.git rebase -i——压缩历史在合并特性分支之前，如果发现已提交的内容中有些许拼写错误，这可以合并到上一个提交压缩成一个历史记录，来保证历史记录的高效性、正确性。（1）创建分支C1$ git checkout -b ccc （2）对文件进行修改（并预留错误），并提交很小的更改可以直接一次性git commit -am&quot;information&quot;，不需要git add， git commit（3）修正代码中错误查看一下当前工作区和暂存树中的不同git diff 并提交1$ git commit -am&quot;Fix typo&quot; 漏字错字等失误称作typo，但是历史记录中不需要出现这类信息，所以要合并到上一个历史记录 （4）更改历史1$ git rebase -i HEAD~2 用这种方法执行git rebase命令，可以选定当前分支中包含HEAD（最新提交）在内的两个最新历史记录为对象，并在编辑器中打开 将ea3730a左侧的pick部分删除，改为fixup，保存编辑器里的内容，关闭编辑器]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web前端规范（一）- JavaScript]]></title>
    <url>%2F2017%2F12%2F28%2Fweb%E5%89%8D%E7%AB%AF%E8%A7%84%E8%8C%83%EF%BC%88%E4%B8%80%EF%BC%89-JavaScript%2F</url>
    <content type="text"><![CDATA[Javascipt空格 使用4个空格作为一个缩进层级 关键字function、if、else、for、switch、do、try等后必须要跟一个空格 具体函数名后的(),不需要跟空格 代码块{}左起的{，前面要跟一个空格 （）或[]，中紧邻的参数不需要跟空格 多个参数时，’,’、’;’;前面不需要空格，若不是最后一个，则后面要跟一个空格 二元运算符左右都必须要跟一个空格 一元运算符与操作对象间不需要跟空格 在对象创建时，属性中的：之前必须要空格，之前不要空格 行尾不要多余的空格 12345678function foo(a, b) &#123; //参数 ，后面要空格 var a = 2;//二元运算符左右都必须要跟一个空格 a++; var obj=&#123; m: 1, //对象创建时，属性中：后面要空格 n: 2 &#125;&#125;]]></content>
      <categories>
        <category>前端规范</category>
      </categories>
      <tags>
        <tag>前端规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react开发路上的QA]]></title>
    <url>%2F2017%2F12%2F27%2Freact%E5%BC%80%E5%8F%91%E8%B7%AF%E4%B8%8A%E7%9A%84QA%2F</url>
    <content type="text"><![CDATA[1、问题123Error: Module &apos;C:\Users\angelama\Desktop\新建文件夹\react-to-do-list\node_modules\babel-core\index.js&apos; is not a loader (must have normal or pitch function) at loadLoader (C:\Users\angelama\Desktop\新建文件夹\react-to-do-list\node_modules\loader-runner\lib\loadLoader.js:35:10) at iteratePitchingLoaders 解决办法： webpack2已经不支持省略loader后缀，需要babel-loader 1234567891011//webpack.config.jsmodule:&#123; //loaders加载器 loaders: [ &#123; test: /\.(js|jsx)$/,//一个匹配loaders所处理的文件的拓展名的正则表达式，这里用来匹配js和jsx文件（必须） exclude: /node_modules/,//屏蔽不需要处理的文件（文件夹）（可选） loader: &apos;babel-loader&apos;//loader的名称（必须） &#125; ] &#125; 2、问题npm run dev报错 12345Invalid configuration object. webpack-dev-server has been initialised using a configuration object that does not match the API schema. - configuration has an unknown property &apos;process&apos;. These properties are valid: object &#123; hot?, hotOnly?, lazy?, bonjour?, host?, allowedHosts?, filename?, publicPath?, port?, socket?, watchOptions?, headers?, clientLogLevel?, overlay?, progress?, key?, cert?, ca?, pfx?, pfxPassphrase?, requestCert?, inline?, disableHostCheck?, public?, https?, contentBase?, watchContentBase?, open?, useLocalIp?, openPage?, features?, compress?, proxy?, historyApiFallback?, staticOptions?, setup?, before?, after?, stats?, reporter?, noInfo?, quiet?, serverSideRender?, index?, log?, warn? &#125; 自动刷新的方式： 在网页中嵌入了一个 iframe ，将我们自己的应用注入到这个 iframe 当中去，因此每次你修改的文件后，都是这个 iframe 进行了 reload 解决办法：修改webpack.config.js配置,不要加 colors,progress 等，webpack2已经不支持这些1234devServer: &#123; historyApiFallback: true, inline: true,//注意：不写hot: true，否则浏览器无法自动更新；也不要写colors:true，progress:true等，webpack2.x已不支持这些&#125;, 3.antd引入样式文件报错：12error in ./node_moudle/antd/dist/antd.css Moudle parse failed:Unexpected character&apos;@&apos; 解决办法：webpack.config.js中 exclude注释掉，不然不会解析node_moudle中的文件 12345&#123; test: /\.(scss|css)$/, use: [&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;sass-loader&apos;], // exclude: /node_modules/, &#125; 4. Q:mac执行git命令时候出现：xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun A:打开终端输入，xcode-select –install 回车后，系统弹出下载xcode，点击确认，下载完成后即可。（实际上不是下载xcode，可能下载xcode有关插件，下载时长约1分钟） Remember, in MAC git is attached to XCode’s Command line tools. Xcode 是运行在操作系统Mac OS X上的集成开发工具（IDE），由苹果公司开发。Xcode是开发OS X 和 iOS 应用程序的最快捷的方式。Xcode 具有统一的用户界面设计，编码、测试、调试都在一个简单的窗口内完成。]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github+hexo搭建博客]]></title>
    <url>%2F2017%2F12%2F15%2Fgithub-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[基本使用1234$ hexo new &quot;page&quot;——新建文章$ hexo clean ——清空缓存（db.json）和已生成的静态文件（public）$ hexo generate —— 生成静态文件$ hexo deploy —— 重新部署到服务器 更换主题你可以到Hexo官网主题页去搜寻自己喜欢的theme。这里以hexo-theme-next为例终端cd到 blog 目录下执行如下命令：1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 终端cd到blog目录下执行如下命令(每次部署文章的步骤)：1$ hexo clean //清除缓存文件 (db.json) 和已生成的静态文件 (public) $ hexo g //生成缓存和静态文件 $ hexo d //重新部署到服务器 初步安装到这就已经可以简单的写文章，运行科，至于更改theme内容，比如名称，描述，头像等去修改blog/_config.yml文件和blog/themes/next/_config.yml文件中对应的属性名称即可， 不要忘记冒号:后加空格。 NexT 使用文档里有极详细的介绍。 参考文章：基础搭建 参考文章：后期功能 统计、搜索 参考文章：优化hexo seo]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack]]></title>
    <url>%2F2017%2F12%2F15%2Fwebpack%2F</url>
    <content type="text"><![CDATA[问题：1、webpack用途2、如何配置使用3、注意事项 先看一个常见的webpack配置文件 12345678910111213141516171819202122232425262728293031323334353637383940var webpack = require(&apos;webpack&apos;);var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);var ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);module.exports = &#123; entry: __dirname + &quot;/app/main.js&quot;, output: &#123; path: __dirname + &quot;/build&quot;, filename: &quot;[name]-[hash].js&quot; &#125;, module: &#123; loaders: [ &#123; test: /\.json$/, loader: &quot;json&quot; &#125;, &#123; test: /\.js$/, exclude: /node_modules/, loader: &apos;babel&apos; &#125;, &#123; test: /\.css$/, loader: ExtractTextPlugin.extract(&apos;style&apos;, &apos;css?modules!postcss&apos;) &#125; ] &#125;, postcss: [ require(&apos;autoprefixer&apos;) ], plugins: [ new HtmlWebpackPlugin(&#123; template: __dirname + &quot;/app/index.tmpl.html&quot; &#125;), new webpack.optimize.OccurenceOrderPlugin(), new webpack.optimize.UglifyJsPlugin(), new ExtractTextPlugin(&quot;[name]-[hash].css&quot;) ]&#125; 常见项目架构，自己上手搭建一个react项目 npm init 新建package.json, 入口文件 index.js webpackjosn.config.js index.js App.js index.html 参考文章入门webpack React+Webpack快速上手指南]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解构函数]]></title>
    <url>%2F2017%2F11%2F12%2F%E8%A7%A3%E6%9E%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[当你排除了所有可能性，还剩下一个时，不管有多么的不可能，那就是真相。—— 亚瑟·柯南·道尔 《福尔摩斯全集》 Syntax 句法 123456789101112131415161718var a,b,rest;[a,b]=[10,20];console.log(a); //10console.log(b); //20[a,b,...rest] = [10,20,30,40,50];console.log(a); //10console.log(b); //20console.log(rest); //[30,40,50](&#123;a,b&#125; = &#123;a:10,b:20&#125;);console.log(a); //10console.log(b); //20(&#123;a,b,...rest&#125;=&#123;a:10,b:20,c:30,d:40&#125;);console.log(a); //10console.log(b); //20console.log(..rest); //&#123;c:30,d:40&#125; 解构赋值 使用同样的语法，但是在赋值的左边定义了从源变量解开什么值 1234var x=[1,2,3,4,5];var [y,z] = x;console.log(y); //1console.log(z); //2 数组解构 Array destructuring 基本变量赋值 Basic variable assignment 12345var foo =[&apos;one&apos;,&apos;two&apos;,&apos;three&apos;];var [x,y,z] = foo;console.log(x); //&quot;one&quot;console.log(y); //&quot;two&quot;console.log(z); //&quot;three&quot; 通过声明各自赋值变量可以通过独立于变量声明的解构来赋值 1234var a,b;[a,b]= [1,2];console.log(a); //1console.log(b); //2 默认值如果没有定义从数组中解压的值，则变量可以被赋默认值 1234var a,b;[a=5,b=7] = [1];console.log(a); //1console.log(b); //7 —— 默认值 交换变量两个变量值可以在一个解构表达式中交换 1234var a=10,b=20;[a,b] = [b,a];console.log(a); //20console.log(b); //10 解析从函数中返回的数组解构可以使数组返回值更简洁 1234567function f()&#123; return [1,2]&#125;var a,b;[a,b] = f();console.log(a); //1console.log(b); //2 忽略一些返回值 123456function f()&#123; return [1,2,3];&#125;var a[a,,b]=f();console.log(a); //1console.log(b); //3 将数组的其余部分分布给一个变量 123var [a,...b] = [1,2,3];console.log(a); //1console.oog(b); //[2,3] 解开正则表达式匹配的值]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记—精通css]]></title>
    <url>%2F2017%2F08%2F12%2FNote%E2%80%94%E7%B2%BE%E9%80%9Acss%2F</url>
    <content type="text"><![CDATA[— 未完待续 3.1.2外边距叠加只有普通文档流中块框的垂直外边距才会发生外边距叠加，行内框、浮动框或绝对定位框之间的外边距不会叠加 3.2定位概述3.2.1可视化格式模型css中有3种基本的定位机制:普通流、浮动、绝对定位。 如何修改行内框的尺寸？1、行内框在一行中水平排列，可以使用水平内边距、边框、外边距调整他们的水平间距2、行内框高度并不受垂直内边距、边框、和外边距的影响3、行内框设置显式的高度和宽度也没有影响4、修改行内框尺寸的唯一办法就是修改行高或者水平边框、水平内边距和外边距 3.2.2相对定位相对定位移动位置之后,元素仍然占据原来的空间，因此，这样移动会造成它覆盖其他框12345.myBox&#123; position:relative; left:20px; top:20px;&#125; ####3.2.3绝对定位相对定位实际上可以看做普通流定位模型中的一部分，因为元素的位置是相对于他在普通流中的位置。绝对定位使元素的位置与文档流无关，因此不占据空间，普通文档流中其他元素的布局就是绝对定位的元素不存在一样。 相对定位是“相对于”元素在文档流中的初始位置，而绝对定位是“相对于”距离它最近的已定位祖先元素，如果不存在已定位的祖先元素，那么相对于初始包含块 3.2.4浮动1、现象浮动会让元素脱离文档流，不再影响不浮动的元素，实际上并不完全如此。浮动元素后面的文档流元素，这个元素的框不受浮动影响，但是其中的文本元素会受影响，会移动以留出空间。技术术语：浮动元素旁边的行框被缩短，从而给浮动元素留出空间，因此行框围绕浮动框。实际上，创建浮动框使文本可以围绕图像。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式-小笔记]]></title>
    <url>%2F2017%2F06%2F12%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式（regular expression）描述了一种字符串匹配的模式，可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串 +表示前面的字符至少出现一次 run00+b,可以匹配run00b、run0000000b *表示前面的字符至少出现0次 run00*b,可以匹配run0b、run0000b ?表示前面的字符最多只出现一次 colou?r可以匹配color或者colour]]></content>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css打造Mac Air]]></title>
    <url>%2F2017%2F03%2F20%2Fcss%E6%89%93%E9%80%A0Mac-Air%2F</url>
    <content type="text"><![CDATA[期待的效果： ####第0步 box-shadow:0 5px 6px rgb(160,160,160);基本语法是{box-shadow:[inset] x-offset y-offset blur-radius spread-radiuscolor}对象选择器 {box-shadow:[投影方式] X轴偏移量 Y轴偏移量阴影模糊半径 阴影扩展半径 阴影颜色} 最后从div的左下角到右上角以60度添加一个线性渐变linear-gradient，是从白色开始从四分之一出过渡到灰色。 linear-gradient css渐变 ####第1步123456789101112.board&#123; background: rgb(210,210,210); width:600px; height:450px; margin:0 auto; -webkit-border-radius:20px; -moz-border-radius:20px; border-radius:20px; box-shadow: 0px 5px 6px rgb(160,160,160);//线性渐变 background: -webkit-linear-gradient(60deg,rgba(250,250,250,1)25%,rgba(210,210,210,1)); &#125; 此时，面板已经打造完成，效果呢，就像下面这个样子，忽略那些字符吧 ####第2步 盖子.board:before{ }伪元素 要设置display属性，才可以确定它的样式，并显示出来 border-top-left-radius：border-bottom-right-radius: length|% [length|%];注释：border-top-left-radius 属性的长度值和百分比值定义四分之一椭圆（定义外部边框边缘的边角形状）的半径（radii）。第一个值是水平半径，第二个值是垂直半径 1234rgb(30,60,100,180,210)各自的颜色趋向box-sizingbox-shadowbackground: -webkit-linear-gradient(top,rgb(30,30,30),rgb(60,60,60)35%,rgb(100,100,100)50%,rgb(30,30,30)65%); 当啷，键盘区画好啦我们用box-shadow给keyboard的四条边框添加四条内部inset阴影，关于box-shadow以后有机会再讲，先把实现和效果贴上： 五、第五步 http://mp.weixin.qq.com/s/K33g-rlU0_AVMQADyPN-Aw]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css命名准则]]></title>
    <url>%2F2017%2F03%2F12%2Fcss%E5%91%BD%E5%90%8D%E5%87%86%E5%88%99%2F</url>
    <content type="text"><![CDATA[####一、名字的本质是什么 对于css，为了避免样式冲突，我们总是会赋予它相当特殊的命名，或者是在选择符上添加HTML标记，或是使用层级。我们会在避免冲突上狠作文章，所谓过犹不及，结果又是一个烂摊子，重用性会很低很低，这就导致本是窈窕淑女，却变得臃肿不堪。例如，下面人人网的css命名（张鑫旭大大说需要这种反面例子的时候就去找人人和新浪，一找一个准(●’◡’●)）： 我们都希望写出精简高效的css代码，如果css重用性越高，就越高效，这个时候命名就要越简单、越容易被重用。BUT，简单的命名越容易造成样式冲突，例如 .more{ }。从这点上来说，【重用性】与【样式冲突】是两个对立的矛盾体。 不过，这种矛盾并不是不可以调和的，记住一些准则和方法，css 既可以有高效的重用性，又不会有样式冲突。 面向属性的命名方法 整理借鉴于张鑫旭大大的博文]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记—Thinking in React]]></title>
    <url>%2F2017%2F03%2F11%2FNote%E2%80%94Thinking-in-React%2F</url>
    <content type="text"><![CDATA[Start with a mock 先来看一个简单设计 JSON API返回如下数据12345678[ &#123;category: &quot;Sporting Goods&quot;, price: &quot;$49.99&quot;, stocked: true, name: &quot;Football&quot;&#125;, &#123;category: &quot;Sporting Goods&quot;, price: &quot;$9.99&quot;, stocked: true, name: &quot;Baseball&quot;&#125;, &#123;category: &quot;Sporting Goods&quot;, price: &quot;$29.99&quot;, stocked: false, name: &quot;Basketball&quot;&#125;, &#123;category: &quot;Electronics&quot;, price: &quot;$99.99&quot;, stocked: true, name: &quot;iPod Touch&quot;&#125;, &#123;category: &quot;Electronics&quot;, price: &quot;$399.99&quot;, stocked: false, name: &quot;iPhone 5&quot;&#125;, &#123;category: &quot;Electronics&quot;, price: &quot;$199.99&quot;, stocked: true, name: &quot;Nexus 7&quot;&#125;]; And then 见证奇迹的时刻到了 ####Step 1: Break the UI into a component hierarchy（将UI划分为组件的层级结构） F：But how do you know what should be its own component?（怎样划分一个组件）Q：Just use the same techniques for deciding if you should create a new function or object. （是否需要创建一个新的函数或者对象） One such technique is the single responsibility principle（单一责任原则）, that is, a component should ideally only do one thing（一个组件应该理想的只做一件事）. If it ends up growing, it should be decomposed into smaller subcomponents. Since you’re often displaying a JSON data model to a user,you’ll find that if your model was built correctly, your UI (and therefore your component structure) will map nicely.（由于您经常向用户显示JSON数据模型，您会发现如果您的模型正确构建，您的UI（因此您的组件结构）将会很好地映射。） That’s because UI and data models tend to adhere to the same information architecture, which means the work of separating your UI into components is often trivial. Just break it up into components that represent exactly one piece of your data model.（这是因为UI和数据模型倾向于遵循相同的信息体系结构，这意味着将UI划分为组件是徒劳无功的。只将其划分为 完全代表一种数据模型 的组件即可） You’ll see here that we have five components in our simple app. I’ve italicized the data each component represents.1.FilterableProductTable (orange): contains the entirety of the example2.SearchBar (blue): receives all user input3.ProductTable (green): displays and filters the data collection based on user input4.ProductCategoryRow (turquoise): displays a heading for each category5.ProductRow (red): displays a row for each product FilterableProductTable SearchBar ProductTable ProductCategoryRow ProductRow ####Step 2: Build a static version in React1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/** * Created by AngelaMa on 2017/2/6. */var FilterableProductTable = React.createClass(&#123; render:function()&#123; return( &lt;div&gt; &lt;SearchBar /&gt;, &lt;ProductTable products=&#123;this.props.products&#125;/&gt; &lt;/div&gt; ); &#125;&#125;);var SearchBar = React.createClass(&#123; render:function()&#123; return( &lt;form&gt; &lt;input type=&quot;text&quot; placeholder=&quot;Search...&quot;/&gt; &lt;p&gt; &lt;input type=&quot;checkbox&quot;/&gt; &#123;&apos; &apos;&#125; Only show products in stock &lt;/p&gt; &lt;/form&gt; ); &#125;&#125;);var ProductTable = React.createClass(&#123; render:function()&#123; var rows=[]; var lastCategory = null; this.props.products.forEach(function(product)&#123; if(product.category !== lastCategory)&#123; rows.push(&lt;ProductCategoryRow category=&#123;product.category&#125; key=&#123;product.category&#125;/&gt;); &#125; rows.push(&lt;ProductRow product=&#123;product&#125; key=&#123;product.name&#125; /&gt;); lastCategory = product.category; &#125;); return( &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Price&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt;&#123;rows&#125;&lt;/tbody&gt; &lt;/table&gt; ); &#125;&#125;);var ProductCategoryRow = React.createClass(&#123; render:function()&#123; return( &lt;tr&gt; &lt;th colSpan=&quot;2&quot;&gt;&#123;this.props.category&#125;&lt;/th&gt; &lt;/tr&gt; ); &#125;&#125;);var ProductRow = React.createClass(&#123; render:function()&#123; var name = this.props.product.stocked? this.props.product.name: &lt;span style=&#123;&#123;color:&apos;red&apos;&#125;&#125;&gt; &#123;this.props.product.name&#125; &lt;/span&gt;; return( &lt;tr&gt; &lt;td&gt;&#123;name&#125;&lt;/td&gt; &lt;td&gt;&#123;this.props.product.price&#125;&lt;/td&gt; &lt;/tr&gt; ); &#125;&#125;);var PRODUCTS = [ &#123;category: &apos;Sporting Goods&apos;, price: &apos;$49.99&apos;, stocked: true, name: &apos;Football&apos;&#125;, &#123;category: &apos;Sporting Goods&apos;, price: &apos;$9.99&apos;, stocked: true, name: &apos;Baseball&apos;&#125;, &#123;category: &apos;Sporting Goods&apos;, price: &apos;$29.99&apos;, stocked: false, name: &apos;Basketball&apos;&#125;, &#123;category: &apos;Electronics&apos;, price: &apos;$99.99&apos;, stocked: true, name: &apos;iPod Touch&apos;&#125;, &#123;category: &apos;Electronics&apos;, price: &apos;$399.99&apos;, stocked: false, name: &apos;iPhone 5&apos;&#125;, &#123;category: &apos;Electronics&apos;, price: &apos;$199.99&apos;, stocked: true, name: &apos;Nexus 7&apos;&#125;];ReactDOM.render( &lt;FilterableProductTable products=&#123;PRODUCTS&#125;/&gt;, document.getElementById(&apos;content&apos;)); It’s best to decouple these processes because building a static version requires a lot of typing and no thinking, and adding interactivity requires a lot of thinking and not a lot of typing.（最好解耦合这些进程，因为建立一个静态的版本需要大量的打字，没有思想，添加交互性需要大量的思考而不是打字。）Props：props are a way of passing data from parent to child.State：State is reserved only for interactivity, that is, data that changes over time.（State仅用于交互性，即随时间变化的数据）In simpler examples, it’s usually easier to go top-down, and on larger projects, it’s easier to go bottom-up and write tests as you build.（在更简单的例子中，通常更容易从上到下，而在更大的项目中，更容易从底层向上和编写测试。）React’s one-way data flow (also called one-way binding) keeps everything modular and fast.（React的单项数据流保证了模块化和快速） ####Step 3: Identify the minimal (but complete) representation of UI state（识别UI状态的最小（但完整）表示）Figure out the absolute minimal representation of the state your application needs and compute everything else you need on-demand. （识别你的应用需要的绝对最小表示，并且计算你需要的所有其他内容）For example, if you’re building a TODO list, just keep an array of the TODO items around; don’t keep a separate state variable for the count.（例如，构建一个TODO List，只需要保留TODO项目的数组，不要为计数保留单独的状态变量） Let’s go through each one and figure out which one is state. Simply ask three questions about each piece of data: Is it passed in from a parent via props? If so, it probably isn’t state.（通过props从父进程而来？） Does it remain unchanged over time? If so, it probably isn’t state.（随时间保持不变？） Can you compute it based on any other state or props in your component? If so, it isn’t state.（根据组件中的）Step 4: Identify where your state should live 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566var FilterableProductTable = React.createClass(&#123; getInitialState: function() &#123; return &#123; filterText: &apos;&apos;, inStockOnly: false &#125;; &#125;, render: function() &#123; return ( &lt;div&gt; &lt;SearchBar filterText=&#123;this.state.filterText&#125; inStockOnly=&#123;this.state.inStockOnly&#125; /&gt; &lt;ProductTable products=&#123;this.props.products&#125; filterText=&#123;this.state.filterText&#125; inStockOnly=&#123;this.state.inStockOnly&#125; /&gt; &lt;/div&gt; ); &#125;&#125;);var SearchBar = React.createClass(&#123; render: function() &#123; return ( &lt;form&gt; &lt;input type=&quot;text&quot; placeholder=&quot;Search...&quot; value=&#123;this.props.filterText&#125; /&gt; &lt;p&gt; &lt;input type=&quot;checkbox&quot; checked=&#123;this.props.inStockOnly&#125; /&gt; &#123;&apos; &apos;&#125; Only show products in stock &lt;/p&gt; &lt;/form&gt; ); &#125;&#125;);var ProductTable = React.createClass(&#123; render: function() &#123; var rows = []; var lastCategory = null; this.props.products.forEach(function(product) &#123; if (product.name.indexOf(this.props.filterText) === -1 || (!product.stocked &amp;&amp; this.props.inStockOnly)) &#123; return; &#125; if (product.category !== lastCategory) &#123; rows.push(&lt;ProductCategoryRow category=&#123;product.category&#125; key=&#123;product.category&#125; /&gt;); &#125; rows.push(&lt;ProductRow product=&#123;product&#125; key=&#123;product.name&#125; /&gt;); lastCategory = product.category; &#125;.bind(this)); return ( &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Price&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt;&#123;rows&#125;&lt;/tbody&gt; &lt;/table&gt; ); &#125;&#125;); ####Step 5: Add inverse data flow（添加逆向数据流） Let’s think about what we want to happen. We want to make sure that whenever the user changes the form, we update the state to reflect the user input. Since components should only update their own state, FilterableProductTable will pass a callback to SearchBar that will fire whenever the state should be updated. We can use the onChange event on the inputs to be notified of it. And the callback passed by FilterableProductTable will call setState(), and the app will be updated.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116var FilterableProductTable = React.createClass(&#123; getInitialState:function()&#123; return&#123; filterText:&apos;&apos;, inStockOnly:false, &#125;; &#125;, handleUserInput:function(filterText,inStockOnly)&#123; this.setState(&#123; filterText:filterText, inStockOnly:inStockOnly &#125;); &#125;, render:function()&#123; return( &lt;div&gt; &lt;SearchBar filterText=&#123;this.state.filterText&#125; inStockOnly=&#123;this.state.inStockOnly&#125; onUserInput=&#123;this.handleUserInput&#125; /&gt;, &lt;ProductTable products=&#123;this.props.products&#125; filterText=&#123;this.state.filterText&#125; inStockOnly=&#123;this.state.inStockOnly&#125; /&gt; &lt;/div&gt; ); &#125;&#125;);var SearchBar = React.createClass(&#123; handleChange:function()&#123; this.props.onUserInput( this.refs.filterTextInput.value, this.refs.inStockOnlyInput.checked ); &#125;, render:function()&#123; return( &lt;form&gt; &lt;input type=&quot;text&quot; placeholder=&quot;Search...&quot; value=&#123;this.props.filterText&#125; ref=&quot;filterTextInput&quot; onChange=&#123;this.handleChange&#125;/&gt; &lt;p&gt; &lt;input type=&quot;checkbox&quot; checked=&#123;this.props.inStockOnly&#125; ref=&quot;inStockOnlyInput&quot; onchange=&#123;this.handleChange&#125;/&gt; &#123;&apos; &apos;&#125; Only show products in stock &lt;/p&gt; &lt;/form&gt; ); &#125;&#125;);var ProductTable = React.createClass(&#123; render:function()&#123; var rows=[]; var lastCategory = null; this.props.products.forEach(function(product)&#123; if (product.name.indexOf(this.props.filterText) === -1 || (!product.stocked &amp;&amp; this.props.inStockOnly)) &#123; return; &#125; if(product.category !== lastCategory)&#123; rows.push(&lt;ProductCategoryRow category=&#123;product.category&#125; key=&#123;product.category&#125;/&gt;); &#125; rows.push(&lt;ProductRow product=&#123;product&#125; key=&#123;product.name&#125; /&gt;); lastCategory = product.category; &#125;.bind(this)); return( &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Price&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt;&#123;rows&#125;&lt;/tbody&gt; &lt;/table&gt; ); &#125;&#125;);var ProductCategoryRow = React.createClass(&#123; render:function()&#123; return( &lt;tr&gt; &lt;th colSpan=&quot;2&quot;&gt;&#123;this.props.category&#125;&lt;/th&gt; &lt;/tr&gt; ); &#125;&#125;);var ProductRow = React.createClass(&#123; render:function()&#123; var name = this.props.product.stocked? this.props.product.name: &lt;span style=&#123;&#123;color:&apos;red&apos;&#125;&#125;&gt; &#123;this.props.product.name&#125; &lt;/span&gt;; return( &lt;tr&gt; &lt;td&gt;&#123;name&#125;&lt;/td&gt; &lt;td&gt;&#123;this.props.product.price&#125;&lt;/td&gt; &lt;/tr&gt; ); &#125;&#125;);var PRODUCTS = [ &#123;category: &apos;Sporting Goods&apos;, price: &apos;$49.99&apos;, stocked: true, name: &apos;Football&apos;&#125;, &#123;category: &apos;Sporting Goods&apos;, price: &apos;$9.99&apos;, stocked: true, name: &apos;Baseball&apos;&#125;, &#123;category: &apos;Sporting Goods&apos;, price: &apos;$29.99&apos;, stocked: false, name: &apos;Basketball&apos;&#125;, &#123;category: &apos;Electronics&apos;, price: &apos;$99.99&apos;, stocked: true, name: &apos;iPod Touch&apos;&#125;, &#123;category: &apos;Electronics&apos;, price: &apos;$399.99&apos;, stocked: false, name: &apos;iPhone 5&apos;&#125;, &#123;category: &apos;Electronics&apos;, price: &apos;$199.99&apos;, stocked: true, name: &apos;Nexus 7&apos;&#125;];ReactDOM.render( &lt;FilterableProductTable products=&#123;PRODUCTS&#125;/&gt;, document.getElementById(&apos;content&apos;));]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css三角形一些不得不说的故事]]></title>
    <url>%2F2017%2F01%2F12%2Fcss%E4%B8%89%E8%A7%92%E5%BD%A2%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%BE%97%E4%B8%8D%E8%AF%B4%E7%9A%84%E6%95%85%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[经常会用到三角形（比如对话啊，气泡之类的地方），用于明确指向发言者总是百度一下成型的写法，一直想研究下，耐不住懒啊终于打败的我的拖延症，整体下那些关于CSS三角形的故事 分为两种 （1）类名；（2）伪类貌似这两种写法都和border脱不了干系，那我们先来看看 border 的到底是如何作用在盒模型上的 随便来个盒模型，当当当123456789.Triangular .bubble&#123; width: 300px; height: 100px; border-top:10px solid #000; border-right:10px solid red; border-bottom:10px solid blue; border-left:10px solid green; margin-top: 20px;&#125; 原来border的四个边，在拐角相遇的时候，各占45°，嗯~ 很合理既然这样，那定义类名写三角形就很简单了 一. 定义类名 让内容为0，需要哪个方向的角，写那个方向的boder即可，需要注意的是，单单只写一个方向的border无效，需要相邻方向的border一起来定义，好比这是公共区域，一个人说了不算 123456789101112131415//两个方向.test&#123; width: 0; height: 0; border-top: 10px solid #000; border-right：10px solid transparent;&#125;//三个方向.test&#123; width: 0; height: 0; border-top: 10px solid #000; border-right：10px solid transparent; border-left：10px solid transparent;&#125; 综上：需要相邻的三个border才能定义一个水平垂直方向的三角形 写的简单一点123456.test&#123; width: 0; height: 0; border: 10px solid transparent; border-top: 10px solid #000;&#125; 第二步，相对父元素定位12345678910111213.father&#123; position:relative;&#125;.test&#123; width: 0; height: 0; border-right: 10px solid #000; border: 10px solid transparent; //定位 position: absolute; left: -10px; top: 10px;&#125; —— 未完待续——二. 利用伪类]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http状态码]]></title>
    <url>%2F2017%2F01%2F02%2Fhttp%E7%8A%B6%E6%80%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[1XX : 信息类，表示收到的web浏览器请求，正在进一步的处理中 2XX ：成功，表示用户请求被正确接收，理解和处理，eg：200 OK 3XX ：重定向，表示请求没有成功，客户必须采取进一步的动作 4XX : 客户端错误，表示客户端提交的请求有错误，例如：404 NOT Found，意味着请求中所引用的文档不存在 5XX ：服务器错误，表示服务器不能完成队对请求的处理]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两个静态html之间相互传值]]></title>
    <url>%2F2016%2F09%2F12%2F%E4%B8%A4%E4%B8%AA%E9%9D%99%E6%80%81html%E4%B9%8B%E9%97%B4%E7%9B%B8%E4%BA%92%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[关键词 ：url主要思想： 通过url 在两个页面之间传值 1、 a.html 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;a&lt;/title&gt; &lt;/head&gt;&lt;body&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot; class=&quot;input7&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;OK&quot; onclick=&quot;show()&quot;/&gt;&lt;script&gt; function show()&#123; var result = document.getElementById(&quot;name&quot;).value; location.href=&quot;b.html?name=&quot;+result; //利用url参数传递！！！&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、b.html 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;b&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;button&quot; onclick=&quot;getValue(&apos;name&apos;)&quot; value=&quot;GetValue&quot;/&gt;&lt;script&gt; function getValue(name) &#123; var str = window.location.search; // location.search是从当前URL的?号开始的字符串 if (str.indexOf(name) != -1) &#123; var pos_start = str.indexOf(name) + name.length + 1; var pos_end = str.indexOf(&quot;&amp;&quot;, pos_start); //检查是否有其他的参数传递 if (pos_end == -1) &#123; alert(str.substring(pos_start)); &#125; else &#123; alert(&quot;没有此值~~&quot;); &#125; &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3、效果图]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
</search>
