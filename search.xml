<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[重新认识js]]></title>
    <url>%2F2018%2F01%2F29%2F%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86js%2F</url>
    <content type="text"><![CDATA[我们似乎很容易就会安于现状，怀疑着、踟蹰着不敢向前迈出一步，但等自己真的尝试去做了，霍然回首，原来也不是很难，又成长了一些。 ——龙龙 《随笔》 前言1995年，netscape公司一位名叫Brendan Eich的工程师创造了JavaScript，当时js名为LiveScript，后来因为sun公司的Java语言的兴起和广泛使用，Netscape出于宣传和推广的考虑，更名为JavaScript。尽管两者之间咩有什么共同点，这便是产生混淆的根源。与大多数编程语言不同，Js并没有输入或输出的概念。他是一个在宿主环境下运行的脚本语言，任何与外界沟通的机制都是由宿主环境提供的。浏览器是最常见的宿主环境，但在非常多的其他程序中也包含JS解释器，如Adobe Acrobat、Photoshop、SVG图像、Yahoo！的Widget引擎，以及Node.js之类的服务器环境。JS的实际应用远不止这些，还有NoSQL数据库、嵌入式计算机，以及包括GNOME在内的桌面环境等等 概览JS是一种面向对象的动态语言，它包含类型、运算符、标准内置对象和方法。 js的语法来源于Java和C，所以这两种语言的许多语法特性同样适用于JavaScropt js并不支持类，类的概念在js中通过对象原型得到延续。 js中的函数也是对象，js允许函数在包含可执行代码的同时，能像其他对象一样被传递 类型 任何编程语言都必不可少的组成部分——类型，js的类型包括（7种） Number（数字） String (字符串) Boolean（布尔值） Symbol（符号）（ES6新增） Object（对象）（万物皆对象） Function（函数） Array（数组） Date（日期） RegExp（正则） Null（空） Undefined(未定义) 数字js采用“IEEE 754”标准定义的双精度64位格式表示数字，和其他编程语言不同，js不区分整数和浮点数，所有数字在js中均用浮点数值表示。在具体实现时，整数值通常被视为32位整型变量。10.1+0.2===0.30000000000000004 //true js支持标准的算术运算符，加减、取模（取余）,内置对象Math等12Math.sin(3.5);var d = Math.PI*(r+r) 内置对象parseInt(),将字符串转化成整型，该函数的第二个参数表示字符串所表示的数字的基（进制）12parseInt(&apos;123&apos;,10);// 123parseInt(&apos;11&apos;,2); // 3 二进制数字字符串转化成整数值 js还有个类似的内置函数parseFloat(),用以解析浮点数字符串，并且只应用于解析十进制数字单元运算符 + 也可以吧数字字符串转换成数值12+ &apos;42&apos;; // 42+ &apos;0x10&apos;; // 16 函数把0x解析成16进制 如果给定的字符串不存在数值形式，函数会返回一个特殊的值 NaN1parseInt(&apos;hello&apos;,10); //NaN 要小心NaN:如果把NaN作为参数进行数学运算，结果也会是NaN：1NaN + 5; // NaN 可以使用内置函数isNaN()来判断一个变量是否为NaN：1isNaN(NaN) //true js还有两个特殊的值:Infinity(正无穷)和-Infinity(负无穷)121/0; //Infinity-1/0; //-Infinity 可以使用内置函数isFinite()来判断一个变量是否是一个有穷数，如果类型为 Infinity、-Infinity、NaN、则返回false1234567isFinite(1/0); //falseisFinite(Infinity); //false finite(有限的、有穷的)isFinite(NaN); //falseisFinite(0); //true Number.isFinite(0); //trueisFinite(&quot;0&quot;);// true 如果是纯数值类型的检测，则返回false Number.isFinite(&quot;0&quot;); //false isFinite(2e74);//true parseInt()和parseFloat()会尝试逐个解析字符串中的字符，直到遇到无法解析的那一个，就返回该字符之前的所有数字; 运算符 + ，只要字符串中含有无法解析的数字，就会返回NaN 字符串js中的字符串是一串 Unicode字符 序列，准确说是一串 UTF-16 编码单元的序列，每一个编码单元由一个16位二进制数表示。每一个Unicode字符由一或两个编码单元表示。如果想表示一个单独的字符，只需要使用长度为1的字符串1&quot;hello&quot;.length; //5 字符串也有methods(方法)123&quot;hello&quot;.charAt(1); // e&quot;hello,world&quot;.replace(&quot;hello&quot;,&quot;goddbye&quot;); //&quot;goodbey,world&quot;&quot;hello&quot;.toUpperCase(); //HELLO 其他类型 null 表示空值，必须使用null关键字才能访问。 undefined 是 未定义 类型的对象，表示一个未初始化的值。一个未被赋值的变量就是undefined类型，undefined实际上是一个不允许修改的值。 boolean，根据需要js可以根据如下规则将变量转换成布尔类型 0、NaN、空字符串(“”)、false、null、undefined 转换为false （ 六种 ） 其他所有值转换为true 变量js与其他语言的重要区别是 js中语句块 是没有 作用域的，只有函数有作用域。如果在复合语句中（例如if）使用var声明一个变量，那么他的作用域是整个函数(复合语句 在 函数中)。但是在es6中,let 和 const 关键字允许创建块作用域的变量 运算符算术运算符+ - * / 和 %(求余)+ 操作符还可以链接字符串（还有 字符串 转换 数字）1&quot;hello&quot; + &quot;Angela&quot; ;// &quot;helloAngela&quot; 如果你用一个字符串加上一个数字，那么操作数都会首先被转换为字符串123 + &quot;2&quot; //&quot;32&quot;&quot;3&quot; + 4 + 6 //&quot;346&quot; 这里有咩有看出一个实用的技巧——通过空字符串相加，可以将某个变量迅速变成 字符串 类型 js的比较操作使用&lt;、&gt;、&lt;=、&gt;=,这些运算符对于数字和字符串都通用。== 和 === ， != 和 !== ,区别是有咩有在比较前 进行 类型自适应（类型转换） 控制结构 if else for while 和 do-while (循环体 至少执行一次) 例如；1234567while(a)&#123; a+=1; a为true，才会执行&#125;do&#123; a+=1; //至少执行一次&#125;while(a&gt;0) &amp;&amp; 和 || 运算符使用 短路逻辑，是否会执行第二个语句取决于 第一个操作数的结果。在需要访问某个对象的属性时，可以使用这个特性先判断对象是对为空1var a = Q &amp;&amp; Q.length 或运算可以用来设置默认值1var name = otherName || &apos;default&apos; 对象js中的对象表现形式为”名——值”对，类似 python中的字典 c/c++中的散列表 Perl 和 Ruby 中的散列（哈希） Java 中的 HashMap php中的关联数组 正因为js中的一切（除了核心类型 core object）都是对象，所以js必然与大量的散列表查找操作有着千丝万缕的联系，而散列表擅长的就是告诉查找 有两种简单的方法可以创建一个对象1var obj = new Object(); 和1var obj = &#123;&#125;; 第二种更方便的方法叫做“对象字面量”，这也是json格式的核心语法，一般我们优先选择第二种。下面的方法创建一个对象原型Person，和原型的对象实例you12345678function Person(name,age)&#123; this.name = name; thia.age = age;&#125;//定义一个对象var you = new Person(&apos;you&apos;,&apos;20&apos;) 创建完成后，对象的属性可以通过如下两种方式进行赋值和访问12obj.name = &apos;angela&apos;;var name = obj.name; 第二种12obj[&apos;name&apos;] = &apos;angela&apos;;var name = obj[&apos;name&apos;]; 这两种方法在语义上是相同的，第二种方法的优点是，属性的名称被看做一个字符串，这意味着她可以在运行时被计算，缺点是有可能在后期无法被解释器优化，他也可以被用来访问某些以 预留关键字作为名称的属性（注：es5开始， 预留关键字可以作为对象的属性名） 数组数组是js中一种特殊的对象，他的工作原理与普通对象类似（以数字为属性名，但只能通过[]来访问），他还有一个特殊的属性 length，这个属性的值比最大索引数大1.12345var a = &#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;&#125;; //数组字面量比 传统的声明数组更加方便a.length; // 3a[100] = &apos;x&apos;;a.length = 101; 记住：数组的长度是比最大索引数 大 1 的数。 如果试图访问一个不存在的索引，会得到 undefined;1typeof(a[90]); //undefined 可以通过如下的方式遍历一个数组：123for(var i = 0; i &lt; a.length; i++)&#123; xxxxx;&#125; 遍历数组的另一种方法是使用 for…in循环，注意，如果有人向Array.prototype中添加了新的属性，使用for…in循环，这些属性也同样会被遍历。所以不推荐这种方法。123for(var i in a)&#123; xxx;&#125; ES5增加了遍历数组的另一种方法，forEach();12345[&apos;a&apos;,&apos;b&apos;&apos;c&apos;].forEach(function(currentValue,index,array)&#123; // do something with currentValue or array[index]&#125;)[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;].forEach(currentValue =&gt; console.log(currentValue)) 如果想在数组后追加元素，只需要1a.push(item); Array类 自带了许多方法。 a.toString(); //返回一个包含数组中所有元素的字符串，每个元素通过逗号分隔 a.toLocaleString(); //根据宿主环境的区域设置，返回一个包含数组中所有元素的字符串，每个元素通过逗号分隔 a.concat(item1,item2,…,itemN); //连接，返回一个数组，包含了原先 a 和 item1,item2,…,itemN中的所有元素 a.join(sep); //返回一个包含数组中所有元素的字符串，每个元素通过指定的sep分隔 a.join(sep).splice(sep); //返回原数组 a.splice(start,delcount,item1,item2,…,itemN);//从start开始，删除delcount个元素。然后插入所有的item a.slice(start,end);//返回子数组，以a[start]开头，以a[end]前一个元素结尾。 a.pop(); //删除并返回 数组中的最后一个元素 a.shift(); //删除并返回 数组中的第一个元素 a.unshift(item);//将item插入数组头部，并返回数组新长度(考虑undefined) a.push(item1,item2); //将item1，item2追加至数组a末尾 a.reverse();//数组逆序 a.sort(cmpfn);//依据cmpfn返回的结果进行排序，如果为指定比较函数，则按字符顺序比较（即使元素是数字） 函数apply()apply()方法调用一个函数，其具有一个指定的this值，以及作为一个数组（或 类似数组的对象），提供的参数。 call()方法与apply()方法类似，只有一个区别，就是call()方法接受的是若干个参数的列表，而apply()方法接受的是一个包含多个参数的数组语法1fun.apply（thisArg,[argsArray]） 参数thisArg 在fun函数运行时指定的this值。需要注意的是，指定的this值并不一定是该函数执行时真正this值，如果这个函数处于非严格模式下，则指定为null或undefined时会自动指向全局对象（浏览器中就是window对象）， 同时值为原始值（数字、字符串、布尔值）的this会指向该原始值的自动包装对象argsArray 一个数组或者类数组对象,其中的数组元素将作为单独的参数传给fun函数。如果该参数的值为null或undefined，则表示不需要传入任何参数 函数1234function add(x, y)&#123; var total = x + y; return total;&#125; return 语句返回一个值并结束函数。如果没有使用return函数语句，或者一个没有值的return语句，JavaScript会返回undefined。函数实际上市访问了函数体中一个名为arguments的内部对象，这个对象就如同一个类似于数组的对象一样，包括了所有被传入的参数。让我们重写一下上面这个函数，使他可以接收任意个数的参数：12345678function add() &#123; var sum = 0; for(var i = 0, j = arguments.length; i &lt; j; i++)&#123; sum += arguments[i]; &#125; return sum;&#125;add(2, 3, 4, 5);//14 求平均数12345678function avg() &#123; var sum = 0; for(var i = 0,j = arguments.length.length; i &lt; j; i++)&#123; sum += arguments[i]; &#125; return sum/arguments.length;&#125;avg(2,3,4,5); //3.5 如果处理一个数组的平均值，js允许使用 任意函数对象的 apply() 方法来调用函数，并传递给他一个包含了参数的数组。1avg.apply(null,[2,3,4,5]); //3.5 js允许以递归的方式调用函数。递归在处理树形结构时非常有用。 自定义对象在经典的面向对象的语言中，对象是指数据和在这些数据上进行的操作的集合，js是一种基于原型的编程语言，并没与class语句，而是把函数用作类。我们来定义一个人名对象，名（first） 姓（last）；姓（last）名(first)12345678910111213141516function makePerson(first,last)&#123; return&#123; first: first, last: last, fullName: function()&#123; return this.first + &apos; &apos; + this.last; &#125;, fullNameReversed: function()&#123; return this.lasr + &apos; &apos; + this.first; &#125;&#125;&#125;s = makePerson(&apos;Angela&apos;,&apos;Ma&apos;);s.fullName(); //Angela mas.fullNameReversed(); Ma Angela 上面的代码中用到了关键字this,当在函数中使用时，this指代当前的对象，也就是调用了函数的对象。如果在一个对象上使用 点或者方括号 来访问属性或者方法，这个对象就成了this。如果并没有使用”点”运算符调用某个对象，那么this将指向全局对象。这是一个经常出错的地方。1234s = makePerson(&apos;Angela&apos;,&apos;Ma&apos;);var fullName = s.fullName();fullName(); //undefined undefinedfullName(&apos;Angela&apos;,&apos;Ma&apos;);// undefined undefined 当我们调用 fullName() 时，this实际上是指向全局对象的，并没有名为first或last的全局变量，所以他们两个的返回值都是 unfined. 下面使用关键字this改进已有的函数1234567891011function Person(first,last) &#123; this.first = first; this.last = last; this.fullName = function() &#123; return this.first + &apos; &apos; + this.last; &#125; this.fullNameReversed = function() &#123; return this.last + &apos; &apos; + this.first; &#125;&#125;var s = new Person(&apos;Angela&apos;,&apos;Ma&apos;); 我们引入了另外一个关键字:new,他和 this 密切相关。他的作用是创建一个崭新的空对象，然后使用指向那个对象的 this 调用特定的函数。注意，含有 this 的特定函数不会返回任何值，只会修改 this 对象本身。 new 关键字将生成的 this 对象返回给调用方，而被 new 调用的函数成为构造函数。 这个改进有相同的问题，单独调用 fullName() 还是undefined 虽然我们的perSon已经相当完善了，但是还有可以改进的地方么？当然，每次我们创建一个Person 对象的时候，我们都在其中创建了两个新的函数对象，如果这个代码可以共享不是更好么 12345678910function Person(first, last)&#123; this.first = first; this.last = last;&#125;Person.prototype.fullName = function() &#123; return this.first + &apos; &apos; + this.last;&#125;Person.prototype.fullNameReversed = function() &#123; return this.last + &apos; &apos; this.first;&#125; Person.protoType 是一个可以被 Person 的所有实例共享的对象。他是一个名叫原型链的查询链的一部分：当你试图访问一个 Person 没有定义的属性时，解释器会首先检查这个 Person.prototype 来判断是都存在这样一个属性。所以，任何分配给 Person.prototype 的东西 对 通过this对象构造的实例 都是可用的。 这个特性功能十分强大，js允许你在程序中的任何时候修改原型中的一些东西，也就是说你可以在运行时给已存在的对象添加额外的方法： 1234567s = new Person(&quot;Angela&quot;, &quot;Ma&quot;);s.firstNameCaps(); // TypeError on line 1: s.firstNameCaps is not a functionPerson.prototype.firstNameCaps = function() &#123; return this.first.toUpperCase()&#125;s.firstNameCaps(); // 有趣的是，还可以给js的内置函数原型添加东西，让我们给 String 添加一个方法用来返回逆序的字符串：1234567891011var s = &apos;Angela&apos;;s.reversed(); // TypeError on line 1: s.reversed is not a functionString.prototype.reversed = function() &#123; var r = &quot;&quot;; for(var i = this.length; i &gt;= 0; i--)&#123; r += this[i]; &#125; return r;&#125;s.reversed(); //alegnA 定义新方法也可以在字符串字面量上用1&quot;This can now be reversed&quot;.reversed(); // desrever eb won nac sihT 正如我前面提到的，原型组成链的一部分。那条链的根节点是 Object.prototype，它包括 toString() 方法——将对象转换成字符串时调用的方法。这对于调试我们的 Person 对象很有用： 1234567var s = new Person(&quot;Simon&quot;, &quot;Willison&quot;);s; // [object Object]Person.prototype.toString = function() &#123; return &apos;&lt;Person: &apos; + this.fullName() + &apos;&gt;&apos;;&#125;s.toString(); // &lt;Person: Simon Willison&gt; 你是否还记得之前我们说的 avg.apply() 中的第一个参数 null？现在我们可以回头看看这个东西了。apply() 的第一个参数应该是一个被当作 this 来看待的对象。下面是一个 new 方法的简单实现：12345function trivialNew(constroctor,...args) &#123; var o = &#123;&#125;; constroctor.apply(o,args); return o;&#125; 这并不是 new 的完整实现，因为它没有创建原型（prototype）链。想举例说明 new 的实现有些困难，因为你不会经常用到这个，但是适当了解一下还是很有用的。在这一小段代码里，…args（包括省略号）叫作剩余参数（rest arguments）。如名所示，这个东西包含了剩下的参数。因此调用1var bill = trivialNew(Person,&quot;Angela&quot;,&quot;Ma&quot;); 可以认为和下面语句是等效的1var bill = new Person(&quot;Angela&quot;,&quot;Ma&quot;); apply() 有一个姐妹函数，名叫 call，它也可以允许你设置 this，但它带有一个扩展的参数列表而不是一个数组。 12345678function lastNameCaps() &#123; return this.last.toUpperCase();&#125;var s = new Person(&quot;Simon&quot;, &quot;Willison&quot;);lastNameCaps.call(s);// 和以下方式等价s.lastNameCaps = lastNameCaps;s.lastNameCaps(); 内部函数js允许在一个函数内部定义函数，一个很重要的细节是他们可以访问父函数作用域中的变量:1234567function betterExampleNeeded() &#123; var a = 1; function oneMoewThanA() &#123; return a + 1; &#125; return onMoreThanA;&#125; 这也是一个减少使用全局变量的好方法。内部函数可以共享父函数的变量，所以可以使用这个特性把一些函数捆绑在一起，这可以有效的防止”污染”全局命名空间——可以称为“局部全局”。 闭包123456789function makeAdder(a) &#123; return function(b) &#123; return a + b; &#125;&#125;var x = makeAdder(5);var y = makeAdder(20);x(6); //11y(7); //27 makeAdder 函数 ：创建了一个新的Adder函数，这个函数自身带有一个参数，他被调用的时候这个参数会被加在外层函数传进来的参数上。 这与内嵌函数十分相似： 一个函数被定义在另一个函数内部，内部函数可以访问外部函数的变量 唯一不同的是，外部函数被返回了，常识告诉我们局部变量“应该”不存在了，但是仍然存在，否则adder函数将不能工作 到底发生了什么？每当js执行一个函数时候，都会创建一个作用域对象，用来保存在这个函数中创建的局部变量。他和被传入函数的变量一起被初始化。这与全局对象和函数的全局对象类似，但仍有一些很重要的区别。 第一、每次函数被执行的时候，都会创建一个 新的、特定的 作用域对象； 第二、与全局对象不同的是，不能直接从js代码中直接访问作用域对象，也没有可以遍历当前作用域对象里面属性的方法 所以当调用makeAdder时，解释器创建了一个作用域对象，它带有一个属性: a,这个属性 被当做参数传入makeAdder函数。然后makeAdder返回一个新创建的函数。通常js的垃圾回收器会在这时回收 makeAdder 创建的作用域对象，但是 返回的函数 却保留了一个指向那个 作用域对象的引用。 结果是这个作用域对象不会被垃圾回收器回收，直到指向 makeAdder 返回的那个 函数对象的引用 计数为零。 作用域对象组成了一个名为 作用域链 的链。它类似于原型链一样，被js的对象系统使用。 一个闭包 就是一个函数 和 被创建的函数中的作用域对象 的组合。 内存泄漏使用闭包的一个坏处是，在IE浏览器中它容易导致 内存泄漏。js是一种具有垃圾回收机制的语言——对象再被创建的时候 分配内存，然后当指向这个对象的引用计数为零时，浏览器会回收内存。宿主环境提供的对象都是按照这种方法被处理的。 浏览器需要处理大量的对象来描绘一个正在被展现的html页面——DOM对象。浏览器负责管理他们的内存分配和回收。 IE浏览器有自己的一套垃圾回收机制，这套机制与js提供的垃圾回收机制进行交互的时候，可能会发生内存泄漏。 在IE中，每当一个js对象 和 一个本地对象 之间形成循环引用时，就会发生内存泄漏。123456// bad function leakMemory() &#123; var el = document.getElementById(&apos;el&apos;); var o = &#123;&apos;el&apos;:el&#125;; el.o = o;&#125; 这段代码的循环引用会导致内存泄漏：IE 不会释放被 el 和 o 使用的内存，直到浏览器被彻底关闭并重启后。 一般也很少发生如此明显的内存泄漏现象——通常泄漏的数据结构有多层的引用，往往掩盖了循环引用的情况。 闭包很容易发生 无意识的内存泄漏。123456function addHandler() &#123; var el = document.getElementById(&apos;el&apos;); el.onclick = function() &#123; el.style.backgroundColor = &apos;red&apos;; &#125;&#125; 这段代码创建了一个元素，当他被点击的时候变红，但同时也发生了内存泄漏。为什么？因为对 el 的引用不小心 放在一个匿名内部函数中。这就在js对象（内部函数） 和 本地对象（el）之间创建了一个循环引用。 这个问题有很多种解决办法，最简单的一种就是不要使用 el 变量12345function addHandler() &#123; document.getElementById(&apos;el&apos;).onclick = function() &#123; this.style.backgroundColor = &apos;red&apos;; &#125;&#125; 另外一种避免闭包的好方法就是在 windows.onunload 事件发生期间破坏 循环引用。许多事件库都能完成这项工作。注意这样做将使 Firefox 中 的becache 无法工作。所以除非有其他必要的原因，最好不要在Firefox中注册一个 onunload 的监听器。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react浅析]]></title>
    <url>%2F2018%2F01%2F28%2Freact%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Change is the only proof of life. —— Evelyn Waugh 《Brideshead Revisited》 所有在JSX中声明的函数，都会被委托在最顶层的document节点上，并用组件名和事件名来存储回调函数，每次当某个组件触发事件时，在document上绑定的监听函数就会找到这个组件和他所有的父组件，对每个组件创建对应的react合成事件，并批处理，从而根据事件名和组件名调用回调函数 关于setState 原理：在执行this.setState()时，react并没有急着立即更新state，而是把新的state存到一个队列中。对传进去的对象进行合并，然后在统一处理，触发重新渲染过程。 setState()并不会立即改变this.state,而是创建一个即将处理的state。setState()并不一定是同步的。为了提升性能React会批量执行state()和DOM渲染 setState()总是会触发一次组件重绘，除非在showComponentUpdate()中实现了一些条件条件渲染逻辑 把setState()看做是重新render的一次请求而不是立即更新组件的指令 Q:调用this.setState()后什么时候this.state才会更新？A:即将要执行下一次的render函数时 组件的生命周期为了更清楚明了的查看组件的生命周期，在每一个生命周期中添加改生命周期的名称发现初次调用时 father was created father componentWillMount render father child was created child compoentWillMount render Child Child componentDidMount Father componentWillUnmount 调用父组件的setState后 Father shouldCompoentUpdate Father compoentWillpdate Father render Child componentWillReceiveProps Child shouldComponentUpdate Child componentWillUpdate render Child Child ComponentDidUpdate Father CompoentDidUpdate 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Child extends React.Component &#123; constructor() &#123; super() console.log(&apos;Child was created!&apos;) &#125; componentWillMount()&#123; console.log(&apos;Child componentWillMount!&apos;) &#125; componentDidMount()&#123; console.log(&apos;Child componentDidMount!&apos;) &#125; componentWillReceiveProps(nextProps)&#123; console.log(&apos;Child componentWillReceiveProps:&apos;+nextProps.data ) &#125; shouldComponentUpdate(nextProps, nextState)&#123; console.log(&apos;Child shouldComponentUpdate:&apos;+ nextProps.data) return true &#125; componentWillUpdate(nextProps, nextState)&#123; console.log(&apos;Child componentWillUpdate:&apos;+ nextProps.data) &#125; componentDidUpdate()&#123; console.log(&apos;Child componentDidUpdate&apos;) &#125; render() &#123; console.log(&apos;render Child!&apos;) return ( &lt;h1&gt;Child recieve props: &#123;this.props.data&#125;&lt;/h1&gt; ); &#125;&#125;class Father extends React.Component &#123; // ... 前面跟子组件一样 handleChangeState()&#123; this.setState(&#123;randomData: Math.floor(Math.random()*50)&#125;) &#125; render() &#123; console.log(&apos;render Father!&apos;) return ( &lt;div&gt; &lt;Child data=&#123;this.state.randomData&#125; /&gt; &lt;h1&gt;Father State: &#123; this.state.randomData&#125;&lt;/h1&gt; &lt;button onClick=&#123;this.handleChangeState&#125;&gt;切换状态&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;React.render( &lt;Father /&gt;, document.getElementById(&apos;root&apos;)); 组件生命周期 参考]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-router温故知新]]></title>
    <url>%2F2018%2F01%2F23%2Freact-router%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%2F</url>
    <content type="text"><![CDATA[谁等待了足够的时间，谁就将永远等待下去，超过了某一个期限，就什么也不会发生了。 —— 塞缪尔·贝克特 《马龙之死》 嵌套注释：导航栏 应该在每一个屏幕中都有，如果没有react router，我们将把ul封装为一个组件，比如Nav，然后将 Nav 渲染近每一个屏幕； 但是随着项目的复杂度的增加，会使得项目代码冗余，react-router提供了另外一种方式和嵌套路由共享UIReact Router embraces this by letting you nest your routes, which automatically becomes nested UI.通过让你嵌套路由，自然形成嵌套的UIThe best way to build large things is to stitch small things together.这是react-router的真正威力，每一条route都可以作为一个独立的应用程序来开发这才是react-route的真正威力 Active LinksLink 不同于 a 标签的一个原因是，Link 可以区别这个链接是否是被激活的(active)，以便于开发者标记不同的样式行内样式 或者 className都是支持的,并且parent routes are active when child routes are active 1234567// modules/App.js&lt;li&gt;&lt;Link to=&quot;/about&quot; activeStyle=&#123;&#123; color: &apos;red&apos; &#125;&#125;&gt;About&lt;/Link&gt;&lt;/li&gt;&lt;li&gt;&lt;Link to=&quot;/repos&quot; activeStyle=&#123;&#123; color: &apos;red&apos; &#125;&#125;&gt;Repos&lt;/Link&gt;&lt;/li&gt;// modules/App.js&lt;li&gt;&lt;Link to=&quot;/about&quot; activeClassName=&quot;active&quot;&gt;About&lt;/Link&gt;&lt;/li&gt;&lt;li&gt;&lt;Link to=&quot;/repos&quot; activeClassName=&quot;active&quot;&gt;Repos&lt;/Link&gt;&lt;/li&gt; 如果将每一个有激活样式的Link都写上样式，会产生很多冗余代码，所以我们可以把有激活样式的Link封装一下,在需要使用的时候 引用 封装后的NavLink1234567891011121314// moudle/NavLink.jsimport React from &apos;react&apos;;import &#123;Link&#125; from &apos;react-router&apos;;export default class NavLink extends React.Component&#123; render()&#123; return &lt;Link &#123;...this.props&#125; activeStyle = &#123;&#123;color:&apos;red&apos;&#125;&#125;&gt;&lt;/Link&gt; &#125;&#125;// moudle/App.js&lt;li&gt;&lt;NavLink to=&quot;/about&quot; &gt;About&lt;/NavLink&gt;&lt;/li&gt;&lt;li&gt;&lt;NavLink to=&quot;/repos&quot; &gt;Repos&lt;/NavLink&gt;&lt;/li&gt; URL Params1/repos/reactjs/react-rpute These URLs would match a route path like this: 1/repos/:userName/:repoName URL中用 ： 开头的参数的值，可以在组件中用 this.props.params[name]取到123456// repo.jsrender()&#123; return( &lt;div &gt;&#123;this.props.params.repoName&#125;&lt;/div&gt; )&#125; 1234// index.js&lt;Route path=&quot;/&quot;&gt; &lt;Route path=&quot;/repo/:about/:URLparams&quot; component=&#123;Repo&#125;&gt;&lt;/Route&gt;&lt;/Route&gt; 引用repo12// about.js&lt;Link to=&quot;/repo/About/URLParams&quot;&gt;点击链接repo.js&lt;/Link&gt; Index Routes当我们访问’/‘时，发现这只是一个导航并且显示一张空包的页面，所以我们可以设置一个默认页面，当App中没有子组件的时候，渲染Home12345678// Home.jsimport React from &apos;react&apos;export default React.createClass(&#123; render() &#123; return &lt;div&gt;Home&lt;/div&gt; &#125;&#125;) 123456789// modules/App.jsimport Home from &apos;./Home&apos;// ...&lt;div&gt; &#123;/* ... */&#125; &#123;this.props.children || &lt;Home/&gt;&#125;&lt;/div&gt;//... 虽然这样也可以运行的很好，但是我们想做的是小apps内构件小app，而不是大的应用程序，所以我们要把Home链接到Route中，像APP和About一样1234567891011121314151617181920212223// index.js// new imports:// add `IndexRoute` to &apos;react-router&apos; importsimport &#123; Router, Route, hashHistory, IndexRoute &#125; from &apos;react-router&apos;// and the Home componentimport Home from &apos;./modules/Home&apos;// ...render(( &lt;Router history=&#123;hashHistory&#125;&gt; &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt; &#123;/* add it here, as a child of `/` */&#125; &lt;IndexRoute component=&#123;Home&#125;/&gt; &lt;Route path=&quot;/repos&quot; component=&#123;Repos&#125;&gt; &lt;Route path=&quot;/repos/:userName/:repoName&quot; component=&#123;Repo&#125;/&gt; &lt;/Route&gt; &lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt; &lt;/Route&gt; &lt;/Router&gt;), document.getElementById(&apos;app&apos;)) Index Links“如果子组件是active状态的，那么父组件一定也是active状态”，‘/’是所有路由的父导航，所以Home一直都是active状态有两种方法可以让router知道点击的是‘index route’,然后只渲染index route IndexLink12345// App.jsimport &#123; IndexLink &#125; from &apos;react-router&apos;// ...&lt;li&gt;&lt;IndexLink to=&quot;/&quot; activeClassName=&quot;active&quot;&gt;Home&lt;/IndexLink&gt;&lt;/li&gt; onlyActiveOnIndex1&lt;li&gt;&lt;Link to=&quot;/&quot; activeClassName=&quot;active&quot; onlyActiveOnIndex=&#123;true&#125;&gt;Home&lt;/Link&gt;&lt;/li&gt; 这样我们要一直记得 activeClassName的类名，因为我们已经抽象出NavLink，而且 记住 我们已经把NavLink 的所有方法，通过{…props}都传递给了Link。所以，我们可以简化1&lt;li&gt;&lt;NavLink to=&quot;/&quot; onlyActiveOnIndex=&#123;true&#125;&gt;Home&lt;/NavLink&gt;&lt;/li&gt; Clean UrlsModern browsers let JavaScript manipulate the URL without making an http request, so we don’t need to rely on the hash (#) portion of the url to do routing, but there’s a catch (we’ll get to it later).译：现代浏览器允许js在不触发http请求的时候操作url，所以我们不需要依赖url的哈希部分来进行路由 Configuring Your Server当切换hashHistory成BrowserHistory之后，发现url中那些 hash 都不见了，url变得很干净，但是有一个问题当刷新页面的时候，就找不到页面了因为无论什么url进来，你的服务器都需要传送给你的应用程序，但是因为应用程序操作了url。所以我们当前的浏览器不知道如何处理这个url。 步骤一：–history-api-fallbackWebpack Dev Server 有一个选项可以解决这个问题 123// package.json&quot;start&quot;: &quot;webpack-dev-server --inline --content-base . --history-api-fallback&quot; 步骤二：在index.html中，把相对路径 改为 绝对路径 123456&lt;!-- index.html --&gt;&lt;!-- index.css -&gt; /index.css --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/index.css&quot;&gt;&lt;!-- bundle.js -&gt; /bundle.js --&gt;&lt;script src=&quot;/bundle.js&quot;&gt;&lt;/script&gt; 如果服务器在运行中，请关掉重新npm start一下，因为改动了index.html不会热加载。 发现的问题BrowserHistory 和 HashHistory 的区别 since server rendering is synchronous and route matching is asynchronous.同步和异步]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>react-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器的工作原理]]></title>
    <url>%2F2018%2F01%2F16%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[人的尊严就在于，能够对我们看似前后矛盾的命运逻辑，反复的质疑。—— 英格玛·伯格曼《第七封印》 浏览器的主要功能 浏览器的主要功能是将用户选择的web资源呈现出来，需要从数据库请求资源，并将其显示在浏览器窗口中，资源的格式通常是html，也包括PDF、image以及其他格式。用户用URL（Uniform Resource Identifier统一资源标识符）来指定请求资源的位置 HTML和CSS规范中规定了浏览器解释html文档的方式，由 W3C组织对这些规范进行维护，W3C是负责制定web标准的组织。 虽然各大浏览器厂商纷纷开发自己的扩展，遵循的规则并不完善，为web开发者带来严重的兼容性问题，但是浏览器的用户界面差不多，常见的用户界面 用来输入URL的地址栏 前进、后退按钮 书签选项 用于刷新、暂停当前加载文档的刷新、暂停按钮 用于到达主页的主页按钮 浏览器的主要构成 用户界面——包括 地址栏、前进后退按钮、书签目录、（所看到的除了用来显示你所请求的页面的主窗口之外的部分） 浏览器引擎——用来查询以操作渲染引擎的接口 渲染引擎——显示请求的内容，例如如果请求的html，他负责解析html及css，并将解析后的结果显示出来 网络——用来完成网络调用，例如http请求，它是平台无关的接口 UI后端——用来绘制类似组合选择框和对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口 JS解释器——用来解释执行js代码 数据存储——属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据 主流程渲染引擎在取得内容之后的基本流程：解析html以构建dom树——&gt;构件render树——&gt;布局render树——&gt;绘制render树 解析 渲染引擎首先解析html，并将标签转化为内容树中的dom节点 解析外部css文件以及style标签中的样式信息。 这些样式信息以及html中的可见性指令用来构建render树 render树构建好了之后，将会执行布局过程，确定每个节点在屏幕上的确切坐标 绘制 即遍历render树，并使用UI后端层绘制每个节点]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[箭头函数]]></title>
    <url>%2F2018%2F01%2F02%2F%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[箭头函数表达式的语法比函数表达式更短，并且不绑定自己的this，arguments，super或 new.target。这些函数表达式最适合用于非方法函数，并且它们不能用作构造函数。 基础语法123456(param1,param2,...,paramN)=&gt;&#123;retrun expression&#125;//只有一个参数时，括号可以选择不加（singleParam）=&gt;&#123;statements&#125; singleParam=&gt;&#123;statements&#125;//当没有参数时，括号是必须的（）=&gt;&#123;statements&#125; 高级语法12345678910//加括号的函数体返回对象字面表达式：param =&gt; (&#123;foo: bar&#125;)//支持剩余参数和默认参数(参数1, 参数2, ...rest) =&gt; &#123;函数声明&#125;(参数1 = 默认值1,参数2, …, 参数N = 默认值N) =&gt; &#123;函数声明&#125;//同样支持参数列表解构let f = ([a, b] = [1, 2], &#123;x: c&#125; = &#123;x: a + b&#125;) =&gt; a + b + c;f(); // 6 描述引入箭头函数的作用：更简短的函数并且不绑定this 更短的函数12345678910111213var materials = [ &apos;Hydrogen&apos;, &apos;Helium&apos;, &apos;Lithium&apos; ]; materials.map(function(materials)&#123; return materials.lemght &#125;); //[8,6,7] materials.map(maters=&gt;&#123; return materials.length &#125;); //[8,6,7] materials.map(masters=&gt;materials.length); // [8,6,7] 注：{}里表达式，需要 return,才会有返回值 不绑定this在箭头函数出现之前，每一个新创建的函数都有自己的this（在构造函数中是一个新对象，在严格模式的函数调用中是undefined，如果该函数被称为‘对象方法’则是基础对象）12]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git用法小结]]></title>
    <url>%2F2018%2F01%2F01%2Fgit%E7%94%A8%E6%B3%95%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在一个日益麻木不仁的世界上，我们的知觉都已生了硬痂。—— 罗伯特·詹姆斯·沃勒 《廊桥遗梦》 第4章 通过实际操作学习git4.1 git基本操作 git init— 初始化仓库生成 .git 文件夹，这个 .git 目录里管理着当前目录内容所需的仓库数据，在Git中，我们将这个目录的内容成为“附属于该仓库的工作树”。 git status— 查看仓库的状态 mkdir abc 创建文件夹abc touch abc.html 创建文件 abc.html git log — 查看提交日志(1) 只显示指定目录、文件的日志 $ git log README.md(2)显示文件的具体改动内容 $ git log -p git diff查看工作树和暂存区的区别不妨养成在$ git commit之前，$ git diff HEAD,查看本次提交和上次提交有什么区别HEAD是指针，指向当前分支的最新一次提交 4.2分支的操作 git branch— 显示分支一览表 $ git checkout -b 创建、切换分支如果你想以当前的master分支为基础创建新的分支，我们需要用到$git checkout -b(1)创建 feature-A 分支，并进行提交1$ git checkout -b feature-A //创建分支 feature-A 等同于12$ git branch feature-A //创建分支$ git checkout feature-A //切换到分支 (2)切换到 master 分支1$git checkout master //checkout 查看 git checkout - ‘-‘ 连字符表示切换回上一个分支 git merge — 合并分支假设feature-A 这个特性分支开发完毕，想要将他合并到主干分支master中。(1)首先切换到 master 分支1$git checkout master (2)然后合并分支， 为了历史记录，需要创建合并提交，因此在合并时加上 --no-ff参数1$ git merge --no-ff feature-A 咳咳咳！！！！敲黑板，这个时候会进入 vim 编辑器状态，想当时我折腾了半天不知道那是个啥随后编辑器会启动，用于录入和并提交的信息，默认信息中已经包含了是从分支合并过来的相关内容，所以保存就好了，然后关闭编辑器先退出输出状态 Esc，然后进入输入状态 shift + ：，最后输入 wq！（保存并退出）vim命令总结(3)成功的话，就会看到 4.. git log --graph — 以图标的形式查看分支此时此刻很有成就感，成功新建了一个分支，并且合并啦 4.3 更改提交的操作 git reset — 回溯历史版本如果此时我想创建一个feature-A 的兄弟分支，feature-B，怎么办呢？那就需要回溯到创建A的分支之前的节点，创建一个B分支，（1）要让仓库的HEAD、暂存区、当前工作树回溯到制定状态，需要用到git reset --hard命令，只需要提供目标时间点的哈希值，就可以完全恢复至改时间点的状态。 （2）此时已经恢复到了创建分支A之前的节点，创建分支B1$ git checkout -b feature-B 随便写点什么，并且提交，一定要提交哦，也就是git add 、git commit，不然没有记录，如果自己不小心把代码搞丢了，是找不到的 （3）分支培育好了，要合并了 ———推进至A分支合并后的状态git log 命令只能查看以当前状态为终点的历史日志，所以这里要使用 git reflog命令，查看当前仓库的操作日志 ，寻找此时的哈希值，然后git reset --hard,之后合并2.git rebase -i——压缩历史在合并特性分支之前，如果发现已提交的内容中有些许拼写错误，这可以合并到上一个提交压缩成一个历史记录，来保证历史记录的高效性、正确性。（1）创建分支C1$ git checkout -b ccc （2）对文件进行修改（并预留错误），并提交很小的更改可以直接一次性git commit -am&quot;information&quot;，不需要git add， git commit（3）修正代码中错误查看一下当前工作区和暂存树中的不同git diff 并提交1$ git commit -am&quot;Fix typo&quot; 漏字错字等失误称作typo，但是历史记录中不需要出现这类信息，所以要合并到上一个历史记录 （4）更改历史1$ git rebase -i HEAD~2 用这种方法执行git rebase命令，可以选定当前分支中包含HEAD（最新提交）在内的两个最新历史记录为对象，并在编辑器中打开 将ea3730a左侧的pick部分删除，改为fixup，保存编辑器里的内容，关闭编辑器]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web前端规范（一）- JavaScript]]></title>
    <url>%2F2017%2F12%2F28%2Fweb%E5%89%8D%E7%AB%AF%E8%A7%84%E8%8C%83%EF%BC%88%E4%B8%80%EF%BC%89-JavaScript%2F</url>
    <content type="text"><![CDATA[Javascipt空格 使用4个空格作为一个缩进层级 关键字function、if、else、for、switch、do、try等后必须要跟一个空格 具体函数名后的(),不需要跟空格 代码块{}左起的{，前面要跟一个空格 （）或[]，中紧邻的参数不需要跟空格 多个参数时，’,’、’;’;前面不需要空格，若不是最后一个，则后面要跟一个空格 二元运算符左右都必须要跟一个空格 一元运算符与操作对象间不需要跟空格 在对象创建时，属性中的：之前必须要空格，之前不要空格 行尾不要多余的空格 12345678function foo(a, b) &#123; //参数 ，后面要空格 var a = 2;//二元运算符左右都必须要跟一个空格 a++; var obj=&#123; m: 1, //对象创建时，属性中：后面要空格 n: 2 &#125;&#125;]]></content>
      <categories>
        <category>前端规范</category>
      </categories>
      <tags>
        <tag>前端规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react开发路上的QA]]></title>
    <url>%2F2017%2F12%2F27%2Freact%E5%BC%80%E5%8F%91%E8%B7%AF%E4%B8%8A%E7%9A%84QA%2F</url>
    <content type="text"><![CDATA[1、问题123Error: Module &apos;C:\Users\angelama\Desktop\新建文件夹\react-to-do-list\node_modules\babel-core\index.js&apos; is not a loader (must have normal or pitch function) at loadLoader (C:\Users\angelama\Desktop\新建文件夹\react-to-do-list\node_modules\loader-runner\lib\loadLoader.js:35:10) at iteratePitchingLoaders 解决办法： webpack2已经不支持省略loader后缀，需要babel-loader 1234567891011//webpack.config.jsmodule:&#123; //loaders加载器 loaders: [ &#123; test: /\.(js|jsx)$/,//一个匹配loaders所处理的文件的拓展名的正则表达式，这里用来匹配js和jsx文件（必须） exclude: /node_modules/,//屏蔽不需要处理的文件（文件夹）（可选） loader: &apos;babel-loader&apos;//loader的名称（必须） &#125; ] &#125; 2、问题npm run dev报错 12345Invalid configuration object. webpack-dev-server has been initialised using a configuration object that does not match the API schema. - configuration has an unknown property &apos;process&apos;. These properties are valid: object &#123; hot?, hotOnly?, lazy?, bonjour?, host?, allowedHosts?, filename?, publicPath?, port?, socket?, watchOptions?, headers?, clientLogLevel?, overlay?, progress?, key?, cert?, ca?, pfx?, pfxPassphrase?, requestCert?, inline?, disableHostCheck?, public?, https?, contentBase?, watchContentBase?, open?, useLocalIp?, openPage?, features?, compress?, proxy?, historyApiFallback?, staticOptions?, setup?, before?, after?, stats?, reporter?, noInfo?, quiet?, serverSideRender?, index?, log?, warn? &#125; 自动刷新的方式： 在网页中嵌入了一个 iframe ，将我们自己的应用注入到这个 iframe 当中去，因此每次你修改的文件后，都是这个 iframe 进行了 reload 解决办法：修改webpack.config.js配置,不要加 colors,progress 等，webpack2已经不支持这些1234devServer: &#123; historyApiFallback: true, inline: true,//注意：不写hot: true，否则浏览器无法自动更新；也不要写colors:true，progress:true等，webpack2.x已不支持这些&#125;, 3.antd引入样式文件报错：12error in ./node_moudle/antd/dist/antd.css Moudle parse failed:Unexpected character&apos;@&apos; 解决办法：webpack.config.js中 exclude注释掉，不然不会解析node_moudle中的文件 12345&#123; test: /\.(scss|css)$/, use: [&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;sass-loader&apos;], // exclude: /node_modules/, &#125; 4. Q:mac执行git命令时候出现：xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun A:打开终端输入，xcode-select –install 回车后，系统弹出下载xcode，点击确认，下载完成后即可。（实际上不是下载xcode，可能下载xcode有关插件，下载时长约1分钟） Remember, in MAC git is attached to XCode’s Command line tools. Xcode 是运行在操作系统Mac OS X上的集成开发工具（IDE），由苹果公司开发。Xcode是开发OS X 和 iOS 应用程序的最快捷的方式。Xcode 具有统一的用户界面设计，编码、测试、调试都在一个简单的窗口内完成。]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github+hexo搭建博客]]></title>
    <url>%2F2017%2F12%2F15%2Fgithub-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[基本使用1234$ hexo new &quot;page&quot;——新建文章$ hexo clean ——清空缓存（db.json）和已生成的静态文件（public）$ hexo generate —— 生成静态文件$ hexo deploy —— 重新部署到服务器 更换主题你可以到Hexo官网主题页去搜寻自己喜欢的theme。这里以hexo-theme-next为例终端cd到 blog 目录下执行如下命令：1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 终端cd到blog目录下执行如下命令(每次部署文章的步骤)：1$ hexo clean //清除缓存文件 (db.json) 和已生成的静态文件 (public) $ hexo g //生成缓存和静态文件 $ hexo d //重新部署到服务器 初步安装到这就已经可以简单的写文章，运行科，至于更改theme内容，比如名称，描述，头像等去修改blog/_config.yml文件和blog/themes/next/_config.yml文件中对应的属性名称即可， 不要忘记冒号:后加空格。 NexT 使用文档里有极详细的介绍。 参考文章：基础搭建 参考文章：后期功能 统计、搜索 参考文章：优化hexo seo]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack]]></title>
    <url>%2F2017%2F12%2F15%2Fwebpack%2F</url>
    <content type="text"><![CDATA[问题：1、webpack用途2、如何配置使用3、注意事项 先看一个常见的webpack配置文件 12345678910111213141516171819202122232425262728293031323334353637383940var webpack = require(&apos;webpack&apos;);var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);var ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);module.exports = &#123; entry: __dirname + &quot;/app/main.js&quot;, output: &#123; path: __dirname + &quot;/build&quot;, filename: &quot;[name]-[hash].js&quot; &#125;, module: &#123; loaders: [ &#123; test: /\.json$/, loader: &quot;json&quot; &#125;, &#123; test: /\.js$/, exclude: /node_modules/, loader: &apos;babel&apos; &#125;, &#123; test: /\.css$/, loader: ExtractTextPlugin.extract(&apos;style&apos;, &apos;css?modules!postcss&apos;) &#125; ] &#125;, postcss: [ require(&apos;autoprefixer&apos;) ], plugins: [ new HtmlWebpackPlugin(&#123; template: __dirname + &quot;/app/index.tmpl.html&quot; &#125;), new webpack.optimize.OccurenceOrderPlugin(), new webpack.optimize.UglifyJsPlugin(), new ExtractTextPlugin(&quot;[name]-[hash].css&quot;) ]&#125; 常见项目架构，自己上手搭建一个react项目 npm init 新建package.json, 入口文件 index.js webpackjosn.config.js index.js App.js index.html 参考文章入门webpack React+Webpack快速上手指南]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解构函数]]></title>
    <url>%2F2017%2F11%2F12%2F%E8%A7%A3%E6%9E%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[我该怎么样生活？这个问题不仅是人生道路之初的问题，更是贯穿人一生的问题。 —— 陈嘉映《何为良好生活》 Syntax 句法 123456789101112131415161718var a,b,rest;[a,b]=[10,20];console.log(a); //10console.log(b); //20[a,b,...rest] = [10,20,30,40,50];console.log(a); //10console.log(b); //20console.log(rest); //[30,40,50](&#123;a,b&#125; = &#123;a:10,b:20&#125;);console.log(a); //10console.log(b); //20(&#123;a,b,...rest&#125;=&#123;a:10,b:20,c:30,d:40&#125;);console.log(a); //10console.log(b); //20console.log(..rest); //&#123;c:30,d:40&#125; 解构赋值 使用同样的语法，但是在赋值的左边定义了从源变量解开什么值 1234var x=[1,2,3,4,5];var [y,z] = x;console.log(y); //1console.log(z); //2 数组解构 Array destructuring 基本变量赋值 Basic variable assignment 12345var foo =[&apos;one&apos;,&apos;two&apos;,&apos;three&apos;];var [x,y,z] = foo;console.log(x); //&quot;one&quot;console.log(y); //&quot;two&quot;console.log(z); //&quot;three&quot; 通过声明各自赋值变量可以通过独立于变量声明的解构来赋值 1234var a,b;[a,b]= [1,2];console.log(a); //1console.log(b); //2 默认值如果没有定义从数组中解压的值，则变量可以被赋默认值 1234var a,b;[a=5,b=7] = [1];console.log(a); //1console.log(b); //7 —— 默认值 交换变量两个变量值可以在一个解构表达式中交换 1234var a=10,b=20;[a,b] = [b,a];console.log(a); //20console.log(b); //10 解析从函数中返回的数组解构可以使数组返回值更简洁 1234567function f()&#123; return [1,2]&#125;var a,b;[a,b] = f();console.log(a); //1console.log(b); //2 忽略一些返回值 123456function f()&#123; return [1,2,3];&#125;var a[a,,b]=f();console.log(a); //1console.log(b); //3 将数组的其余部分分布给一个变量 123var [a,...b] = [1,2,3];console.log(a); //1console.oog(b); //[2,3] 解开正则表达式匹配的值]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记—精通css]]></title>
    <url>%2F2017%2F08%2F12%2FNote%E2%80%94%E7%B2%BE%E9%80%9Acss%2F</url>
    <content type="text"><![CDATA[— 未完待续 3.1.2外边距叠加只有普通文档流中块框的垂直外边距才会发生外边距叠加，行内框、浮动框或绝对定位框之间的外边距不会叠加 3.2定位概述3.2.1可视化格式模型css中有3种基本的定位机制:普通流、浮动、绝对定位。 如何修改行内框的尺寸？1、行内框在一行中水平排列，可以使用水平内边距、边框、外边距调整他们的水平间距2、行内框高度并不受垂直内边距、边框、和外边距的影响3、行内框设置显式的高度和宽度也没有影响4、修改行内框尺寸的唯一办法就是修改行高或者水平边框、水平内边距和外边距 3.2.2相对定位相对定位移动位置之后,元素仍然占据原来的空间，因此，这样移动会造成它覆盖其他框12345.myBox&#123; position:relative; left:20px; top:20px;&#125; ####3.2.3绝对定位相对定位实际上可以看做普通流定位模型中的一部分，因为元素的位置是相对于他在普通流中的位置。绝对定位使元素的位置与文档流无关，因此不占据空间，普通文档流中其他元素的布局就是绝对定位的元素不存在一样。 相对定位是“相对于”元素在文档流中的初始位置，而绝对定位是“相对于”距离它最近的已定位祖先元素，如果不存在已定位的祖先元素，那么相对于初始包含块 3.2.4浮动1、现象浮动会让元素脱离文档流，不再影响不浮动的元素，实际上并不完全如此。浮动元素后面的文档流元素，这个元素的框不受浮动影响，但是其中的文本元素会受影响，会移动以留出空间。技术术语：浮动元素旁边的行框被缩短，从而给浮动元素留出空间，因此行框围绕浮动框。实际上，创建浮动框使文本可以围绕图像。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间戳]]></title>
    <url>%2F2017%2F07%2F02%2F%E6%97%B6%E9%97%B4%E6%88%B3%2F</url>
    <content type="text"><![CDATA[你可以过闲云野鹤的生活，但是请先明白人间疾苦，你不用成为强大的人，但请一定成为懂得思考自身的人。——周宏翔 《名丽场》 日期转换为时间戳 不要时分秒转换为时间戳的函数 getTime();但是只有 Date()格式的时间，才可以转换为时间戳，换言之形如：Fri Feb 02 2018 11:23:40 GMT+0800 (CST)12345678910var data = new Date(); // data : Fri Feb 02 2018 11:23:40 GMT+0800 (CST)data.getTime(); // 1517541820502//只要年月日的时间戳，就需要 Date日期格式 只含有 年月日，时分秒为0 var data2 = new Date().toLocaleDateString(); //Date 的 toLocaleDateString 方法console.log(data2); // &quot;2018/2/2&quot; (现在时间为 2018/2/2)//把这个时间转换为 Date格式var value = new Date(data2).getTime(); //1517500800000 转换为时间戳方法总结： data.getTime(); //1517541820502 data.valueOf(); //1517541820502 Date.parse(data); //1517541820000 前两种方法精确到毫秒，后面一种 只能精确到秒，毫秒部分 用000 代替 时间戳转换为日期1234567891011var date = new Date(时间戳);var year = date.getFullYear(); //获取完整年份 2018var month = date.getMonth(); //获取月份（0-11） 要+1；var day = date.getDate(); //获取日期（1-31）var hour = date.Hours(); //获取小时数（0-23）var minutes = date.getMinutes(); //获取分钟数（0-59）var seconds = date.getSeconds(); //获取秒数 （0-59）var times = date.getTime(); //获取时间戳，从1970.1.1年开始的毫秒数var today = date.toLocaleDateString(); // toLocaleDateString() 方法可根据本地时间把 Date 对象的日期部分转换为字符串，并返回结果]]></content>
      <tags>
        <tag>时间戳</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式-小笔记]]></title>
    <url>%2F2017%2F06%2F12%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式（regular expression）描述了一种字符串匹配的模式，可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串 +表示前面的字符至少出现一次 run00+b,可以匹配run00b、run0000000b *表示前面的字符至少出现0次 run00*b,可以匹配run0b、run0000b ?表示前面的字符最多只出现一次 colou?r可以匹配color或者colour]]></content>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css打造Mac Air]]></title>
    <url>%2F2017%2F03%2F20%2Fcss%E6%89%93%E9%80%A0Mac-Air%2F</url>
    <content type="text"><![CDATA[期待的效果： ####第0步 box-shadow:0 5px 6px rgb(160,160,160);基本语法是{box-shadow:[inset] x-offset y-offset blur-radius spread-radiuscolor}对象选择器 {box-shadow:[投影方式] X轴偏移量 Y轴偏移量阴影模糊半径 阴影扩展半径 阴影颜色} 最后从div的左下角到右上角以60度添加一个线性渐变linear-gradient，是从白色开始从四分之一出过渡到灰色。 linear-gradient css渐变 ####第1步123456789101112.board&#123; background: rgb(210,210,210); width:600px; height:450px; margin:0 auto; -webkit-border-radius:20px; -moz-border-radius:20px; border-radius:20px; box-shadow: 0px 5px 6px rgb(160,160,160);//线性渐变 background: -webkit-linear-gradient(60deg,rgba(250,250,250,1)25%,rgba(210,210,210,1)); &#125; 此时，面板已经打造完成，效果呢，就像下面这个样子，忽略那些字符吧 ####第2步 盖子.board:before{ }伪元素 要设置display属性，才可以确定它的样式，并显示出来 border-top-left-radius：border-bottom-right-radius: length|% [length|%];注释：border-top-left-radius 属性的长度值和百分比值定义四分之一椭圆（定义外部边框边缘的边角形状）的半径（radii）。第一个值是水平半径，第二个值是垂直半径 1234rgb(30,60,100,180,210)各自的颜色趋向box-sizingbox-shadowbackground: -webkit-linear-gradient(top,rgb(30,30,30),rgb(60,60,60)35%,rgb(100,100,100)50%,rgb(30,30,30)65%); 当啷，键盘区画好啦我们用box-shadow给keyboard的四条边框添加四条内部inset阴影，关于box-shadow以后有机会再讲，先把实现和效果贴上： 五、第五步 http://mp.weixin.qq.com/s/K33g-rlU0_AVMQADyPN-Aw]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css命名准则]]></title>
    <url>%2F2017%2F03%2F12%2Fcss%E5%91%BD%E5%90%8D%E5%87%86%E5%88%99%2F</url>
    <content type="text"><![CDATA[####一、名字的本质是什么 对于css，为了避免样式冲突，我们总是会赋予它相当特殊的命名，或者是在选择符上添加HTML标记，或是使用层级。我们会在避免冲突上狠作文章，所谓过犹不及，结果又是一个烂摊子，重用性会很低很低，这就导致本是窈窕淑女，却变得臃肿不堪。例如，下面人人网的css命名（张鑫旭大大说需要这种反面例子的时候就去找人人和新浪，一找一个准(●’◡’●)）： 我们都希望写出精简高效的css代码，如果css重用性越高，就越高效，这个时候命名就要越简单、越容易被重用。BUT，简单的命名越容易造成样式冲突，例如 .more{ }。从这点上来说，【重用性】与【样式冲突】是两个对立的矛盾体。 不过，这种矛盾并不是不可以调和的，记住一些准则和方法，css 既可以有高效的重用性，又不会有样式冲突。 面向属性的命名方法 整理借鉴于张鑫旭大大的博文]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记—Thinking in React]]></title>
    <url>%2F2017%2F03%2F11%2FNote%E2%80%94Thinking-in-React%2F</url>
    <content type="text"><![CDATA[Start with a mock 先来看一个简单设计 JSON API返回如下数据12345678[ &#123;category: &quot;Sporting Goods&quot;, price: &quot;$49.99&quot;, stocked: true, name: &quot;Football&quot;&#125;, &#123;category: &quot;Sporting Goods&quot;, price: &quot;$9.99&quot;, stocked: true, name: &quot;Baseball&quot;&#125;, &#123;category: &quot;Sporting Goods&quot;, price: &quot;$29.99&quot;, stocked: false, name: &quot;Basketball&quot;&#125;, &#123;category: &quot;Electronics&quot;, price: &quot;$99.99&quot;, stocked: true, name: &quot;iPod Touch&quot;&#125;, &#123;category: &quot;Electronics&quot;, price: &quot;$399.99&quot;, stocked: false, name: &quot;iPhone 5&quot;&#125;, &#123;category: &quot;Electronics&quot;, price: &quot;$199.99&quot;, stocked: true, name: &quot;Nexus 7&quot;&#125;]; And then 见证奇迹的时刻到了 ####Step 1: Break the UI into a component hierarchy（将UI划分为组件的层级结构） F：But how do you know what should be its own component?（怎样划分一个组件）Q：Just use the same techniques for deciding if you should create a new function or object. （是否需要创建一个新的函数或者对象） One such technique is the single responsibility principle（单一责任原则）, that is, a component should ideally only do one thing（一个组件应该理想的只做一件事）. If it ends up growing, it should be decomposed into smaller subcomponents. Since you’re often displaying a JSON data model to a user,you’ll find that if your model was built correctly, your UI (and therefore your component structure) will map nicely.（由于您经常向用户显示JSON数据模型，您会发现如果您的模型正确构建，您的UI（因此您的组件结构）将会很好地映射。） That’s because UI and data models tend to adhere to the same information architecture, which means the work of separating your UI into components is often trivial. Just break it up into components that represent exactly one piece of your data model.（这是因为UI和数据模型倾向于遵循相同的信息体系结构，这意味着将UI划分为组件是徒劳无功的。只将其划分为 完全代表一种数据模型 的组件即可） You’ll see here that we have five components in our simple app. I’ve italicized the data each component represents.1.FilterableProductTable (orange): contains the entirety of the example2.SearchBar (blue): receives all user input3.ProductTable (green): displays and filters the data collection based on user input4.ProductCategoryRow (turquoise): displays a heading for each category5.ProductRow (red): displays a row for each product FilterableProductTable SearchBar ProductTable ProductCategoryRow ProductRow ####Step 2: Build a static version in React1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/** * Created by AngelaMa on 2017/2/6. */var FilterableProductTable = React.createClass(&#123; render:function()&#123; return( &lt;div&gt; &lt;SearchBar /&gt;, &lt;ProductTable products=&#123;this.props.products&#125;/&gt; &lt;/div&gt; ); &#125;&#125;);var SearchBar = React.createClass(&#123; render:function()&#123; return( &lt;form&gt; &lt;input type=&quot;text&quot; placeholder=&quot;Search...&quot;/&gt; &lt;p&gt; &lt;input type=&quot;checkbox&quot;/&gt; &#123;&apos; &apos;&#125; Only show products in stock &lt;/p&gt; &lt;/form&gt; ); &#125;&#125;);var ProductTable = React.createClass(&#123; render:function()&#123; var rows=[]; var lastCategory = null; this.props.products.forEach(function(product)&#123; if(product.category !== lastCategory)&#123; rows.push(&lt;ProductCategoryRow category=&#123;product.category&#125; key=&#123;product.category&#125;/&gt;); &#125; rows.push(&lt;ProductRow product=&#123;product&#125; key=&#123;product.name&#125; /&gt;); lastCategory = product.category; &#125;); return( &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Price&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt;&#123;rows&#125;&lt;/tbody&gt; &lt;/table&gt; ); &#125;&#125;);var ProductCategoryRow = React.createClass(&#123; render:function()&#123; return( &lt;tr&gt; &lt;th colSpan=&quot;2&quot;&gt;&#123;this.props.category&#125;&lt;/th&gt; &lt;/tr&gt; ); &#125;&#125;);var ProductRow = React.createClass(&#123; render:function()&#123; var name = this.props.product.stocked? this.props.product.name: &lt;span style=&#123;&#123;color:&apos;red&apos;&#125;&#125;&gt; &#123;this.props.product.name&#125; &lt;/span&gt;; return( &lt;tr&gt; &lt;td&gt;&#123;name&#125;&lt;/td&gt; &lt;td&gt;&#123;this.props.product.price&#125;&lt;/td&gt; &lt;/tr&gt; ); &#125;&#125;);var PRODUCTS = [ &#123;category: &apos;Sporting Goods&apos;, price: &apos;$49.99&apos;, stocked: true, name: &apos;Football&apos;&#125;, &#123;category: &apos;Sporting Goods&apos;, price: &apos;$9.99&apos;, stocked: true, name: &apos;Baseball&apos;&#125;, &#123;category: &apos;Sporting Goods&apos;, price: &apos;$29.99&apos;, stocked: false, name: &apos;Basketball&apos;&#125;, &#123;category: &apos;Electronics&apos;, price: &apos;$99.99&apos;, stocked: true, name: &apos;iPod Touch&apos;&#125;, &#123;category: &apos;Electronics&apos;, price: &apos;$399.99&apos;, stocked: false, name: &apos;iPhone 5&apos;&#125;, &#123;category: &apos;Electronics&apos;, price: &apos;$199.99&apos;, stocked: true, name: &apos;Nexus 7&apos;&#125;];ReactDOM.render( &lt;FilterableProductTable products=&#123;PRODUCTS&#125;/&gt;, document.getElementById(&apos;content&apos;)); It’s best to decouple these processes because building a static version requires a lot of typing and no thinking, and adding interactivity requires a lot of thinking and not a lot of typing.（最好解耦合这些进程，因为建立一个静态的版本需要大量的打字，没有思想，添加交互性需要大量的思考而不是打字。）Props：props are a way of passing data from parent to child.State：State is reserved only for interactivity, that is, data that changes over time.（State仅用于交互性，即随时间变化的数据）In simpler examples, it’s usually easier to go top-down, and on larger projects, it’s easier to go bottom-up and write tests as you build.（在更简单的例子中，通常更容易从上到下，而在更大的项目中，更容易从底层向上和编写测试。）React’s one-way data flow (also called one-way binding) keeps everything modular and fast.（React的单项数据流保证了模块化和快速） ####Step 3: Identify the minimal (but complete) representation of UI state（识别UI状态的最小（但完整）表示）Figure out the absolute minimal representation of the state your application needs and compute everything else you need on-demand. （识别你的应用需要的绝对最小表示，并且计算你需要的所有其他内容）For example, if you’re building a TODO list, just keep an array of the TODO items around; don’t keep a separate state variable for the count.（例如，构建一个TODO List，只需要保留TODO项目的数组，不要为计数保留单独的状态变量） Let’s go through each one and figure out which one is state. Simply ask three questions about each piece of data: Is it passed in from a parent via props? If so, it probably isn’t state.（通过props从父进程而来？） Does it remain unchanged over time? If so, it probably isn’t state.（随时间保持不变？） Can you compute it based on any other state or props in your component? If so, it isn’t state.（根据组件中的）Step 4: Identify where your state should live 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566var FilterableProductTable = React.createClass(&#123; getInitialState: function() &#123; return &#123; filterText: &apos;&apos;, inStockOnly: false &#125;; &#125;, render: function() &#123; return ( &lt;div&gt; &lt;SearchBar filterText=&#123;this.state.filterText&#125; inStockOnly=&#123;this.state.inStockOnly&#125; /&gt; &lt;ProductTable products=&#123;this.props.products&#125; filterText=&#123;this.state.filterText&#125; inStockOnly=&#123;this.state.inStockOnly&#125; /&gt; &lt;/div&gt; ); &#125;&#125;);var SearchBar = React.createClass(&#123; render: function() &#123; return ( &lt;form&gt; &lt;input type=&quot;text&quot; placeholder=&quot;Search...&quot; value=&#123;this.props.filterText&#125; /&gt; &lt;p&gt; &lt;input type=&quot;checkbox&quot; checked=&#123;this.props.inStockOnly&#125; /&gt; &#123;&apos; &apos;&#125; Only show products in stock &lt;/p&gt; &lt;/form&gt; ); &#125;&#125;);var ProductTable = React.createClass(&#123; render: function() &#123; var rows = []; var lastCategory = null; this.props.products.forEach(function(product) &#123; if (product.name.indexOf(this.props.filterText) === -1 || (!product.stocked &amp;&amp; this.props.inStockOnly)) &#123; return; &#125; if (product.category !== lastCategory) &#123; rows.push(&lt;ProductCategoryRow category=&#123;product.category&#125; key=&#123;product.category&#125; /&gt;); &#125; rows.push(&lt;ProductRow product=&#123;product&#125; key=&#123;product.name&#125; /&gt;); lastCategory = product.category; &#125;.bind(this)); return ( &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Price&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt;&#123;rows&#125;&lt;/tbody&gt; &lt;/table&gt; ); &#125;&#125;); ####Step 5: Add inverse data flow（添加逆向数据流） Let’s think about what we want to happen. We want to make sure that whenever the user changes the form, we update the state to reflect the user input. Since components should only update their own state, FilterableProductTable will pass a callback to SearchBar that will fire whenever the state should be updated. We can use the onChange event on the inputs to be notified of it. And the callback passed by FilterableProductTable will call setState(), and the app will be updated.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116var FilterableProductTable = React.createClass(&#123; getInitialState:function()&#123; return&#123; filterText:&apos;&apos;, inStockOnly:false, &#125;; &#125;, handleUserInput:function(filterText,inStockOnly)&#123; this.setState(&#123; filterText:filterText, inStockOnly:inStockOnly &#125;); &#125;, render:function()&#123; return( &lt;div&gt; &lt;SearchBar filterText=&#123;this.state.filterText&#125; inStockOnly=&#123;this.state.inStockOnly&#125; onUserInput=&#123;this.handleUserInput&#125; /&gt;, &lt;ProductTable products=&#123;this.props.products&#125; filterText=&#123;this.state.filterText&#125; inStockOnly=&#123;this.state.inStockOnly&#125; /&gt; &lt;/div&gt; ); &#125;&#125;);var SearchBar = React.createClass(&#123; handleChange:function()&#123; this.props.onUserInput( this.refs.filterTextInput.value, this.refs.inStockOnlyInput.checked ); &#125;, render:function()&#123; return( &lt;form&gt; &lt;input type=&quot;text&quot; placeholder=&quot;Search...&quot; value=&#123;this.props.filterText&#125; ref=&quot;filterTextInput&quot; onChange=&#123;this.handleChange&#125;/&gt; &lt;p&gt; &lt;input type=&quot;checkbox&quot; checked=&#123;this.props.inStockOnly&#125; ref=&quot;inStockOnlyInput&quot; onchange=&#123;this.handleChange&#125;/&gt; &#123;&apos; &apos;&#125; Only show products in stock &lt;/p&gt; &lt;/form&gt; ); &#125;&#125;);var ProductTable = React.createClass(&#123; render:function()&#123; var rows=[]; var lastCategory = null; this.props.products.forEach(function(product)&#123; if (product.name.indexOf(this.props.filterText) === -1 || (!product.stocked &amp;&amp; this.props.inStockOnly)) &#123; return; &#125; if(product.category !== lastCategory)&#123; rows.push(&lt;ProductCategoryRow category=&#123;product.category&#125; key=&#123;product.category&#125;/&gt;); &#125; rows.push(&lt;ProductRow product=&#123;product&#125; key=&#123;product.name&#125; /&gt;); lastCategory = product.category; &#125;.bind(this)); return( &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Price&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt;&#123;rows&#125;&lt;/tbody&gt; &lt;/table&gt; ); &#125;&#125;);var ProductCategoryRow = React.createClass(&#123; render:function()&#123; return( &lt;tr&gt; &lt;th colSpan=&quot;2&quot;&gt;&#123;this.props.category&#125;&lt;/th&gt; &lt;/tr&gt; ); &#125;&#125;);var ProductRow = React.createClass(&#123; render:function()&#123; var name = this.props.product.stocked? this.props.product.name: &lt;span style=&#123;&#123;color:&apos;red&apos;&#125;&#125;&gt; &#123;this.props.product.name&#125; &lt;/span&gt;; return( &lt;tr&gt; &lt;td&gt;&#123;name&#125;&lt;/td&gt; &lt;td&gt;&#123;this.props.product.price&#125;&lt;/td&gt; &lt;/tr&gt; ); &#125;&#125;);var PRODUCTS = [ &#123;category: &apos;Sporting Goods&apos;, price: &apos;$49.99&apos;, stocked: true, name: &apos;Football&apos;&#125;, &#123;category: &apos;Sporting Goods&apos;, price: &apos;$9.99&apos;, stocked: true, name: &apos;Baseball&apos;&#125;, &#123;category: &apos;Sporting Goods&apos;, price: &apos;$29.99&apos;, stocked: false, name: &apos;Basketball&apos;&#125;, &#123;category: &apos;Electronics&apos;, price: &apos;$99.99&apos;, stocked: true, name: &apos;iPod Touch&apos;&#125;, &#123;category: &apos;Electronics&apos;, price: &apos;$399.99&apos;, stocked: false, name: &apos;iPhone 5&apos;&#125;, &#123;category: &apos;Electronics&apos;, price: &apos;$199.99&apos;, stocked: true, name: &apos;Nexus 7&apos;&#125;];ReactDOM.render( &lt;FilterableProductTable products=&#123;PRODUCTS&#125;/&gt;, document.getElementById(&apos;content&apos;));]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css三角形一些不得不说的故事]]></title>
    <url>%2F2017%2F01%2F12%2Fcss%E4%B8%89%E8%A7%92%E5%BD%A2%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%BE%97%E4%B8%8D%E8%AF%B4%E7%9A%84%E6%95%85%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[经常会用到三角形（比如对话啊，气泡之类的地方），用于明确指向发言者总是百度一下成型的写法，一直想研究下，耐不住懒啊终于打败的我的拖延症，整体下那些关于CSS三角形的故事 分为两种 （1）类名；（2）伪类貌似这两种写法都和border脱不了干系，那我们先来看看 border 的到底是如何作用在盒模型上的 随便来个盒模型，当当当123456789.Triangular .bubble&#123; width: 300px; height: 100px; border-top:10px solid #000; border-right:10px solid red; border-bottom:10px solid blue; border-left:10px solid green; margin-top: 20px;&#125; 原来border的四个边，在拐角相遇的时候，各占45°，嗯~ 很合理既然这样，那定义类名写三角形就很简单了 一. 定义类名 让内容为0，需要哪个方向的角，写那个方向的boder即可，需要注意的是，单单只写一个方向的border无效，需要相邻方向的border一起来定义，好比这是公共区域，一个人说了不算 123456789101112131415//两个方向.test&#123; width: 0; height: 0; border-top: 10px solid #000; border-right：10px solid transparent;&#125;//三个方向.test&#123; width: 0; height: 0; border-top: 10px solid #000; border-right：10px solid transparent; border-left：10px solid transparent;&#125; 综上：需要相邻的三个border才能定义一个水平垂直方向的三角形 写的简单一点123456.test&#123; width: 0; height: 0; border: 10px solid transparent; border-top: 10px solid #000;&#125; 第二步，相对父元素定位12345678910111213.father&#123; position:relative;&#125;.test&#123; width: 0; height: 0; border-right: 10px solid #000; border: 10px solid transparent; //定位 position: absolute; left: -10px; top: 10px;&#125; 利用伪类也是很常用的方法，实现方法类似]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http状态码]]></title>
    <url>%2F2017%2F01%2F02%2Fhttp%E7%8A%B6%E6%80%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[1XX : 信息类，表示收到的web浏览器请求，正在进一步的处理中 2XX ：成功，表示用户请求被正确接收，理解和处理，eg：200 OK 3XX ：重定向，表示请求没有成功，客户必须采取进一步的动作 4XX : 客户端错误，表示客户端提交的请求有错误，例如：404 NOT Found，意味着请求中所引用的文档不存在 5XX ：服务器错误，表示服务器不能完成队对请求的处理]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两个静态html之间相互传值]]></title>
    <url>%2F2016%2F09%2F12%2F%E4%B8%A4%E4%B8%AA%E9%9D%99%E6%80%81html%E4%B9%8B%E9%97%B4%E7%9B%B8%E4%BA%92%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[关键词 ：url主要思想： 通过url 在两个页面之间传值 1、 a.html 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;a&lt;/title&gt; &lt;/head&gt;&lt;body&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot; class=&quot;input7&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;OK&quot; onclick=&quot;show()&quot;/&gt;&lt;script&gt; function show()&#123; var result = document.getElementById(&quot;name&quot;).value; location.href=&quot;b.html?name=&quot;+result; //利用url参数传递！！！&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、b.html 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;b&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;button&quot; onclick=&quot;getValue(&apos;name&apos;)&quot; value=&quot;GetValue&quot;/&gt;&lt;script&gt; function getValue(name) &#123; var str = window.location.search; // location.search是从当前URL的?号开始的字符串 if (str.indexOf(name) != -1) &#123; var pos_start = str.indexOf(name) + name.length + 1; var pos_end = str.indexOf(&quot;&amp;&quot;, pos_start); //检查是否有其他的参数传递 if (pos_end == -1) &#123; alert(str.substring(pos_start)); &#125; else &#123; alert(&quot;没有此值~~&quot;); &#125; &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3、效果图]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
</search>
